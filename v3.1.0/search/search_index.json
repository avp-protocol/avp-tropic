{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to the documentation page for Libtropic!</p> <p>Libtropic is a C-based Software Development Kit (SDK) developed by Tropic Square. Designed for seamless integration, it offers a user-friendly, high-level API that enables host platforms to easily interface with the TROPIC01 secure element.</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Tutorials: Quickly get started with Libtropic on supported platforms.</li> <li>Reference: Everything about Libtropic.</li> <li>Compatibility: Hardware/software supported by Libtropic.</li> <li>For Contributors: Start developing with or contributing to Libtropic.</li> <li>FAQ: Frequently Asked Questions, solutions to common problems.</li> </ul>"},{"location":"faq/","title":"FAQ","text":"<p>This list might help you resolve some issues.</p> <ul> <li>FAQ</li> <li>I received an error<ul> <li><code>LT_L1_CHIP_BUSY</code></li> <li><code>LT_L1_CHIP_ALARM_MODE</code></li> <li><code>LT_L2_HSK_ERR</code></li> <li><code>LT_L3_DATA_LEN_ERROR</code></li> <li><code>LT_L3_INVALID_CMD</code> or <code>LT_L2_UNKNOWN_REQ</code></li> </ul> </li> <li>I cannot establish a Secure Session</li> <li>FW update failed</li> <li>What is the part number (P/N) of my TROPIC01?</li> <li>What is the silicon revision of my TROPIC01?</li> <li>What FW versions is my TROPIC01 running?</li> </ul>"},{"location":"faq/#i-received-an-error","title":"I received an error","text":"<p>Description of all return values is in the <code>libtropic_common.h</code> (<code>lt_ret_t</code> enum). However, some errors may have a seemingly unrelated cause; see the following paragraphs.</p>"},{"location":"faq/#lt_l1_chip_busy","title":"<code>LT_L1_CHIP_BUSY</code>","text":"<p>Normally, this means that the chip is busy processing an operation and is unable to respond. However, it can also mean that the SPI lines (mainly <code>MISO</code>) are tied to ground (causing the host to receive all zeroes). Check your connections.</p> <p>The reason is that we detect the status of the TROPIC01 using a single flag; if all data are zero, we cannot distinguish between the TROPIC01 being truly busy and the host receiving only zeroes.</p>"},{"location":"faq/#lt_l1_chip_alarm_mode","title":"<code>LT_L1_CHIP_ALARM_MODE</code>","text":"<p>Normally, this means the TROPIC01 entered Alarm Mode. However, it can also mean \u2014 similarly to <code>LT_L1_CHIP_BUSY</code> \u2014 that all ones are received on <code>MISO</code>. Check your connections.</p>"},{"location":"faq/#lt_l2_hsk_err","title":"<code>LT_L2_HSK_ERR</code>","text":"<p>This error is caused by a problem during Secure Session establishment. See I cannot establish a Secure Session.</p>"},{"location":"faq/#lt_l3_data_len_error","title":"<code>LT_L3_DATA_LEN_ERROR</code>","text":"<p>This error normally means that the L3 packet size we sent to the TROPIC01 is incorrect, which can be caused by a bug or an attack. However, it can also mean that the chip select is connected incorrectly. Check your connections and GPIO assignments.</p> <p>Chip Select Handling</p> <p>We use a GPIO to handle chip select, not the SPI peripheral's native chip select output.</p>"},{"location":"faq/#lt_l3_invalid_cmd-or-lt_l2_unknown_req","title":"<code>LT_L3_INVALID_CMD</code> or <code>LT_L2_UNKNOWN_REQ</code>","text":"<p>This error means that the TROPIC01 does not recognize the L3 command or L2 request it received. However, this behavior can be caused by the TROPIC01 being in Maintenance Mode. Maintenance Mode does not implement the entire API \u2014 it does not implement <code>Handshake_Req</code> nor any L3 commands, so handshake attempts will always fail.</p> <p>A TROPIC01 will be in Maintenance Mode after a user-triggered reboot (calling <code>lt_reboot</code> with <code>TR01_MAINTENANCE_REBOOT</code> as <code>startup_id</code>). In that case, reboot the chip back to Application Mode by calling <code>lt_reboot</code> with <code>TR01_REBOOT</code>.</p> <p>However, a TROPIC01 can also enter Maintenance Mode automatically after an unsuccessful update or if firmware banks are empty or corrupted. In that case, a simple reboot will not help; you must run the firmware update again, either using the firmware update example (see Tutorials) or from your application code.</p>"},{"location":"faq/#i-cannot-establish-a-secure-session","title":"I cannot establish a Secure Session","text":"<p>There are two main causes:</p> <ol> <li> <p>You are using incorrect pairing keys.    All new TROPIC01s use production pairing keys, which are used by default in Libtropic. Some devkits still contain preview chips (engineering samples). For those, you need to use different keys. Refer to the Default Pairing Keys for a Secure Channel Handshake.</p> </li> <li> <p>Your TROPIC01 is in Maintenance Mode.    Reboot to Application Mode by calling <code>lt_reboot</code> with <code>TR01_REBOOT</code>.</p> </li> </ol>"},{"location":"faq/#fw-update-failed","title":"FW update failed","text":"<p>If our firmware update example program in the tutorial failed:</p> <ol> <li>Try the suggestions in I received an error.</li> <li>Make sure you have correct values set in the following CMake options:<ul> <li>LT_SILICON_REV,</li> <li>LT_CPU_FW_UPDATE_DATA_VER.</li> </ul> </li> <li>Make sure you are not attempting a firmware downgrade \u2014 TROPIC01 does not allow this.</li> </ol>"},{"location":"faq/#what-is-the-part-number-pn-of-my-tropic01","title":"What is the part number (P/N) of my TROPIC01?","text":"<p>You have two options:</p> <ol> <li>Read it from the packaging you received your TROPIC01 product in.</li> <li>Run our example Identify Chip (see Tutorials), which does not require the Secure Channel Session.</li> </ol>"},{"location":"faq/#what-is-the-silicon-revision-of-my-tropic01","title":"What is the silicon revision of my TROPIC01?","text":"<p>You have two options:</p> <ol> <li>Read the product number (P/N) from the packaging you received your TROPIC01 product in. After that, refer to the Available Parts section (in the TROPIC01 GitHub repository) and read the linked Catalog list, which will help you decode the silicon revision based on your P/N.</li> <li>Run our example Identify Chip (see Tutorials), which does not require the Secure Channel Session.</li> </ol>"},{"location":"faq/#what-fw-versions-is-my-tropic01-running","title":"What FW versions is my TROPIC01 running?","text":"<p>Run our example Identify Chip (see Tutorials), which does not require the Secure Channel Session.</p>"},{"location":"common/examples_descriptions/fw_update/","title":"Fw update","text":"<p>This example explains the firmware update process for both ABAB and ACAB silicon revisions. Use this example as a reference for integrating TROPIC01 firmware updates into your application. You will learn:</p> <ul> <li>How to read the current firmware versions.</li> <li>How to update the firmware using <code>lt_do_mutable_fw_update()</code>.</li> </ul> <p>TROPIC01 Firmware</p> <p>For more information about the firmware itself, refer to the TROPIC01 Firmware section.</p> <p>Firmware Update Precautions</p> <p>Use a stable power source and avoid disconnecting the TROPIC01 (devkit) or rebooting your host device (computer or microcontroller) during the update. Interrupting the firmware update can brick the device.</p>"},{"location":"common/examples_descriptions/hello_world/","title":"Hello world","text":"<p>This example demonstrates the basic Libtropic API and can be used to verify that the chip works correctly. In this example, you will learn about the following functions:</p> <ul> <li><code>lt_init()</code>: function used to initialize context for communication with the TROPIC01,</li> <li><code>lt_verify_chip_and_start_secure_session()</code>: helper function to start Secure Session and allow L3 communication,</li> <li><code>lt_ping()</code>: L3 command to verify communication with the TROPIC01,</li> <li><code>lt_session_abort()</code>: L3 command to abort Secure Session,</li> <li><code>lt_deinit()</code>: function used to deinitialize context.</li> </ul>"},{"location":"common/examples_descriptions/identify_chip/","title":"Identify chip","text":"<p>This example demonstrates how to read and display the chip\u2019s unique ID and firmware version information (bootloader, application and SPECT firmware versions). You will learn about the following functions:</p> <ul> <li><code>lt_reboot()</code>: L2 request to reboot to either Application or Maintenance Mode,</li> <li><code>lt_get_info_riscv_fw_ver()</code>, <code>lt_get_info_spect_fw_ver()</code>: L2 requests to read RISC-V CPU and SPECT firmware versions,</li> <li><code>lt_get_info_chip_id()</code>: L2 request to read chip identification (e.g., serial number).</li> </ul>"},{"location":"compatibility/","title":"Compatibility","text":"<p>This section provides information about supported hardware/software:</p> <ul> <li>Host Platforms</li> <li>Cryptographic Functionality Providers</li> </ul>"},{"location":"compatibility/cfps/","title":"Cryptographic Functionality Providers","text":"<p>These are the currently supported CFPs (Cryptographic Functionality Providers):</p> <ul> <li>Crypto libraries:<ul> <li>Trezor Crypto</li> <li>MbedTLS</li> <li>OpenSSL</li> <li>WolfCrypt</li> </ul> </li> </ul> <p>All CAL (Crypto Abstraction Layer) files can be found in the <code>libtropic/cal/</code> directory.</p> <p>Tip</p> <p>Cannot see your CFP in the list above? Refer to Adding a New Cryptographic Functionality Provider section with instructions on how to add support for it.</p>"},{"location":"compatibility/cfps/mbedtls/","title":"MbedTLS","text":"<p>Currently, we support the MbedTLS v4.0.0 and use the PSA Crypto API, which differs from the legacy MbedTLS API in several ways:</p> <ol> <li>Key Management: Keys are imported into PSA key store and referenced by key ID.</li> <li>Context Types: PSA uses opaque context structures (<code>psa_hash_operation_t</code>, etc.).</li> <li>Error Handling: Uses <code>psa_status_t</code> return codes.</li> <li>API Design: Higher-level, more abstract operations (e.g., <code>psa_aead_encrypt</code> vs manual GCM operations).</li> </ol> <p>CAL files of this port are available in the <code>libtropic/cal/mbedtls_v4/</code> directory.</p>"},{"location":"compatibility/cfps/mbedtls/#initialization-and-deinitialization","title":"Initialization and Deinitialization","text":"<p>Libtropic does not handle initialization and deinitialization of MbedTLS, this is the user's responsibility. Specifically, it is assumed that:</p> <ol> <li>psa_crypto_init() is called before the instance of the CAL is handed to Libtropic's <code>lt_init()</code>. See the Libtropic Bare-Bone Example for more information about the CAL instance.</li> <li>mbedtls_psa_crypto_free() is called in the user's application cleanup logic. Although freeing the MbedTLS's resources is not required by Libtropic, it cannot be called sooner than the last call of Libtropic's <code>lt_deinit()</code>, otherwise all Secure Channel Session related commands will return with errors.</li> </ol>"},{"location":"compatibility/cfps/mbedtls/#configuration","title":"Configuration","text":"<p>PSA Crypto must be configured with the following features:</p> <ul> <li><code>PSA_WANT_ALG_GCM</code> - AES-GCM authenticated encryption.</li> <li><code>PSA_WANT_ALG_SHA_256</code> - SHA-256 hashing.</li> <li><code>PSA_WANT_ALG_HMAC</code> - HMAC operations.</li> <li><code>PSA_WANT_ALG_ECDH</code> - X25519 key agreement.</li> <li><code>PSA_WANT_ECC_MONTGOMERY_255</code> - Curve25519 support.</li> <li><code>PSA_WANT_KEY_TYPE_AES</code> - AES key support.</li> <li><code>PSA_WANT_KEY_TYPE_HMAC</code> - HMAC key support.</li> <li><code>PSA_WANT_KEY_TYPE_ECC_KEY_PAIR</code> - ECC key pair support.</li> <li><code>PSA_WANT_KEY_TYPE_ECC_PUBLIC_KEY</code> - ECC public key support.</li> </ul>"},{"location":"compatibility/cfps/mbedtls/#implementation-notes","title":"Implementation Notes","text":""},{"location":"compatibility/cfps/mbedtls/#including-psa-crypto-headers","title":"Including PSA Crypto Headers","text":"<p>The MbedTLS headers contain some redundant declarations, see this issue on GitHub. As the errors are present in headers, not in the implementation files (.c), our strict compilation flags catch those problems, even though we restrict compilation with strict flags only to our own code. To keep ability to use this flag without triggering compilation errors due problems with PSA Crypto, we have to wrap <code>#include</code> like following: <pre><code>#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wredundant-decls\"\n#include \"psa/crypto.h\"\n#pragma GCC diagnostic pop\n</code></pre></p> <p>The pragmas will disable this flag only for the PSA Crypto code.</p>"},{"location":"compatibility/cfps/mbedtls/#macros","title":"Macros","text":"<p>MbedTLS does not define macros for all sizes we need, sometimes they define macros only inside their implementation files ad-hoc. As such, we opted to use some of our macros.</p>"},{"location":"compatibility/cfps/openssl/","title":"OpenSSL","text":"<p>Implementation of the OpenSSL CAL relies on EVP, a high level interface for OpenSSL cryptographic functions.</p> <p>CAL files of this port are available in the <code>libtropic/cal/openssl/</code> directory.</p>"},{"location":"compatibility/cfps/trezor_crypto/","title":"Trezor Crypto","text":"<p>Trezor Crypto is a cryptography library developed by Trezor and available as a part of the Trezor Firmware repository.</p> <p>CAL files of this port are available in the <code>libtropic/cal/trezor_crypto/</code> directory.</p> <p>Due to historical reasons and testing purposes, we have our own copy of the Trezor Crypto in the <code>vendor/</code> directory, as the Trezor Crypto is a part of a Trezor Firmware repository and does not use CMake.</p> <p>Trezor Crypto Version</p> <p>We strongly advise users that want to use Trezor Crypto in production applications to not use our out-of-date copy of Trezor Crypto inside <code>vendor/</code>, but use the version found in the Trezor Firmware repository instead and handle the dependency themselves.</p> <p>TROPIC01 PKI Chain Validation</p> <p>TROPIC01 PKI chain validation cannot be done using the Trezor Crypto only, additional crypto libraries have to be used. If you need to validate the chain, use other supported libraries that provide the required functionality.</p>"},{"location":"compatibility/cfps/wolfcrypt/","title":"WolfCrypt","text":"<p>WolfCrypt is a cryptography library which is part of WolfSSL embedded SSL/TLS library.</p> <p>WolfSSL Licensing</p> <p>WolfSSL is licensed under GPLv3, meaning that when you use Libtropic with WolfCrypt (e.g. when building our tests with the WolfCrypt CAL), you are creating a GPLv3 licensed binary. If you require a non-GPL binary, you must obtain a commercial license from wolfSSL Inc.</p> <p>CAL files of this port are available in the <code>libtropic/cal/wolfcrypt/</code> directory.</p>"},{"location":"compatibility/cfps/wolfcrypt/#configuration","title":"Configuration","text":"<p>WolfSSL must be configured with the following features (CMake options):</p> <ul> <li><code>WOLFSSL_AESGCM</code>,</li> <li><code>WOLFSSL_SHA256</code>,</li> <li><code>WOLFSSL_CURVE25519</code>.</li> </ul>"},{"location":"compatibility/cfps/wolfcrypt/#initialization-and-deinitialization","title":"Initialization and Deinitialization","text":"<p>Libtropic does not handle initialization and deinitialization of WolfCrypt, this is the user's responsibility. Specifically, it is assumed that:</p> <ol> <li>wolfCrypt_Init is called before the instance of the CAL is handed to Libtropic's <code>lt_init</code> function. See the Libtropic Bare-Bone Example for more information about the CAL instance.</li> <li>wolfCrypt_Cleanup is called in the user's application cleanup logic. Although freeing the WolfCrypt's resources is not required by Libtropic, it cannot be called sooner than the last call of Libtropic's <code>lt_deinit</code> function, otherwise all Secure Channel Session related commands will return with errors.</li> </ol>"},{"location":"compatibility/cfps/wolfcrypt/#cryptographic-callbacks","title":"Cryptographic Callbacks","text":"<p>The Cryptographic callbacks are currently not supported by the CAL.</p>"},{"location":"compatibility/host_platforms/","title":"Host Platforms","text":"<p>These are the currently supported host platforms:</p> <ul> <li>STM32</li> <li>ESP32</li> <li>Linux</li> <li>POSIX</li> <li>Arduino</li> </ul> <p>All HAL files can be found in the <code>libtropic/hal/</code> directory.</p> <p>Tip</p> <p>Cannot see your platform in the list above? Refer to Adding a New Host Platform section with instructions on how to add a support for it.</p>"},{"location":"compatibility/host_platforms/arduino/","title":"Arduino","text":"<p>We provide a HAL which utilizes only the Arduino API, making it compatible with all Arduino platforms. The HAL is implemented in the <code>libtropic/hal/arduino/</code> directory.</p> <p>We also provide the libtropic-arduino repository, which follows the directory structure of Arduino libraries and implements support for PlatformIO. Refer to the repository for more information.</p> <p>Disclaimer</p> <p>The Arduino HAL is not suitable for production use. We strongly recommend using it for demo projects only.</p>"},{"location":"compatibility/host_platforms/esp32/","title":"ESP32","text":"<p>To support the widest range of Espressif SoCs possible, we provide a HAL directly for the Espressif IoT Development Framework (ESP-IDF). The HAL is available in the <code>libtropic/hal/esp-idf/</code> directory.</p> <p>ESP-IDF Version</p> <p>The ESP-IDF version tested with Libtropic is 5.5.1.</p> <p>Currently tested ESP32 boards are:</p> <ul> <li>ESP32-DevKitC-V4</li> <li>ESP32-S3-DevKitC-1</li> <li>ESP32-C3-DevKit-RUST-1</li> </ul> <p>See our ESP32 Tutorials to quickly get started.</p>"},{"location":"compatibility/host_platforms/esp32/#initialization","title":"Initialization","text":"<p>If Libtropic's LT_USE_INT_PIN CMake option is used, the ESP-IDF HAL will use GPIO interrupts. This puts a requirement on your application \u2014 in your code, call the <code>gpio_install_isr_service</code> function with parameter <code>0</code> before calling <code>lt_init</code>. This function has to be called exactly once in your application. See the ESP32 examples in the <code>examples/esp32/</code> directory for inspiration.</p>"},{"location":"compatibility/host_platforms/linux/","title":"Linux","text":"<p>Libtropic support on Linux is implemented with:</p> <ul> <li>SPI and GPIO Linux Userspace API</li> <li>SPI and GPIO Linux Userspace API with native CS</li> </ul> <p>HALs for these ports are available in the <code>libtropic/hal/linux/</code> directory.</p> <p>See our Linux SPI Tutorials to quickly get started.</p>"},{"location":"compatibility/host_platforms/linux/#spi-and-gpio-linux-userspace-api","title":"SPI and GPIO Linux Userspace API","text":"<p>This port uses the SPI and GPIO Linux Userspace API. It was tested on:</p> <ul> <li>Raspberry Pi 4,</li> <li>Raspberry Pi 5.</li> </ul> <p>Examples for this port are in the <code>examples/linux/spi_devkit</code> directory.</p>"},{"location":"compatibility/host_platforms/linux/#spi-and-gpio-linux-userspace-api-with-native-cs","title":"SPI and GPIO Linux Userspace API with native CS","text":"<p>Warning</p> <p>This port is experimental. It can be modified or removed in the next release without notice. As such, no examples are provided.</p> <p>This port uses the SPI and GPIO Linux Userspace API.</p> <p>The main difference from the SPI and GPIO Linux Userspace API port is that the GPIO is used only for interrupt handling, as the chip select is handled natively by the SPI driver. The main benefit is that no additional GPIO pin is required and no GPIOs are required at all if interrupts are not used. However, more data are transmitted on each transaction, as this port has no custom control over chip select, meaning it needs to transfer whole buffer on each transaction.</p> <p>This port was tested on:</p> <ul> <li>Raspberry Pi 4</li> </ul>"},{"location":"compatibility/host_platforms/posix/","title":"POSIX","text":"<p>We provide the following ports, which should be compatible with most POSIX compliant operating systems:</p> <ul> <li>TCP</li> <li>TROPIC01 USB Devkit</li> </ul> <p>HALs for these ports are available in the <code>libtropic/hal/posix/</code> directory.</p>"},{"location":"compatibility/host_platforms/posix/#tcp","title":"TCP","text":"<p>We use this port with the TROPIC01 Python Model, which acts as a server, to which Libtropic connects via the specified TCP port. See our TROPIC01 Model Tutorials to quickly get started.</p> <p>Disclaimer</p> <p>The TCP HAL is implemented with consideration of the following:</p> <ol> <li>It is primarily targeted for use with the TROPIC01 Python Model.</li> <li>To ensure reproducibility of randomized functional tests, the rand function is used in the <code>lt_port_random_bytes</code> function with a known random seed instead of more cryptographically secure solutions.</li> </ol> <p>Interrupt Pin Support</p> <p>The TCP HAL does not support TROPIC01's interrupt pin.</p>"},{"location":"compatibility/host_platforms/posix/#tropic01-usb-devkit","title":"TROPIC01 USB Devkit","text":"<p>Libtropic communicates with our USB Devkits using the USB protocol. See our TROPIC01 USB Devkit Tutorials to quickly get started.</p> <p>Raspberry Pi 4 Issues</p> <p>When testing with Raspberry Pi 4, we have encountered issues with its USB, which seems to lose some of the USB packets sent to it.</p> <p>Raspberry Pi 5</p> <p>Fortunately, Raspberry Pi 5 fixes these issues and the USB Devkit works without any issues.</p> <p>Interrupt Pin Support</p> <p>The USB Devkit port does not support TROPIC01's interrupt pin.</p>"},{"location":"compatibility/host_platforms/stm32/","title":"STM32","text":"<p>Currently supported STM32 platforms are:</p> <ul> <li>NUCLEO-F439ZI</li> <li>NUCLEO-L432KC<ul> <li>Using interrupt pin (<code>LT_USE_INT_PIN</code>) is not supported for this platform.</li> </ul> </li> </ul> <p>HALs for these ports are available in the <code>libtropic/hal/stm32/</code> directory.</p> <p>See our STM32 Tutorials to quickly get started.</p>"},{"location":"doxygen/mainpage/","title":"Introduction","text":"<p>Welcome to the documentation for the Libtropic API!</p> <p>For more information about Libtropic, visit the Libtropic repository.</p>"},{"location":"doxygen/mainpage/#documentation-structure","title":"Documentation Structure","text":"<p>The documentation is organized into the following sections:</p> <ul> <li>Introduction: This page.</li> <li>Topics: Detailed documentation of macros, functions, and data structures, organized by the individual components of the Libtropic SDK.</li> <li>Data Structures: A comprehensive overview and index of all available data structures in the Libtropic SDK.</li> <li>Files: A list of all header files included in the SDK, along with their descriptions.</li> </ul> <p>We hope this documentation helps you make the most of the Libtropic SDK. If you have any questions or need further assistance, please refer to the repository, or, if you are a customer, contact the support team.</p>"},{"location":"for_contributors/","title":"For Contributors","text":"<ul> <li>Contributing Guide</li> <li>Building the Documentation</li> <li>Tests</li> <li>Adding a New Host Platform</li> <li>Adding a New Cryptographic Functionality Provider</li> </ul>"},{"location":"for_contributors/adding_cfp/","title":"Adding a New Cryptographic Functionality Provider","text":"<p>Because Libtropic is designed to run on the Host MCU, it requires certain cryptographic functionality \u2014 for example, to decrypt incoming L3 packets from TROPIC01. To enable this, Libtropic defines a Crypto Abstraction Layer (CAL) to abstract the functionality required from a chosen Cryptographic Functionality Provider (CFP). CFP can implement the function either purely in software (using a cryptographic library) or in hardware (using a cryptographic hardware accelerator) or by combining both (e.g., implement all operations in MbedTLS except of the AES-GCM, which will be handled by a STM32's peripheral). This interface-based design makes it easy to integrate and support additional CFPs in the future.</p>"},{"location":"for_contributors/adding_cfp/#requirements","title":"Requirements","text":"<p>The new CFP has to support the following schemes:</p> <ul> <li>AES-GCM<ul> <li>encryption</li> <li>decryption</li> </ul> </li> <li>SHA256<ul> <li>hashing</li> </ul> </li> <li>Curve25519<ul> <li>multiplication on both arbitrary and base point</li> </ul> </li> </ul>"},{"location":"for_contributors/adding_cfp/#guide","title":"Guide","text":"<p>To add support for a new CFP (let's say <code>mycrypto</code>):</p> <ol> <li>Create and Implement the CAL C Files,</li> <li>Create and Implement the CAL CMakeLists.txt,</li> <li>Provide Some Information About the CAL.</li> </ol> <p>Get Inspired by Existing CALs</p> <p>For inspiration, see the existing CALs inside <code>cal/</code>.</p> <p>After these steps, the sources and include directories of the new CAL should be available in consumer's <code>CMakeLists.txt</code> by calling: <pre><code>add_subdirectory(\"&lt;path_to_libtropic&gt;/cal/mycrypto\")\n</code></pre></p> <p>By doing this, the CMake variables <code>LT_CAL_SRCS</code> and <code>LT_CAL_INC_DIRS</code> will become available to the consumer.</p>"},{"location":"for_contributors/adding_cfp/#create-and-implement-the-cal-c-files","title":"Create and Implement the CAL C Files","text":"<ol> <li>Inside <code>cal/</code>, create a new directory called <code>mycrypto</code>.</li> <li>Inside <code>cal/mycrypto/</code>, create the following source files:<ul> <li><code>lt_mycrypto_common.c</code></li> <li><code>lt_mycrypto_aesgcm.c</code>,</li> <li><code>lt_mycrypto_sha256.c</code>,</li> <li><code>lt_mycrypto_hmac_sha256.c</code>,</li> <li><code>lt_mycrypto_x25519.c</code>.</li> </ul> </li> <li> <p>In each of the source files, implement all required functions \u2014 they are declared in the respective headers inside the <code>libtropic/src/</code> directory:</p> <ul> <li><code>lt_crypto_common.h</code>: Common CAL functions,</li> <li><code>lt_aesgcm.h</code>: AES-GCM functions,</li> <li><code>lt_sha256.h</code>: SHA256 functions,</li> <li><code>lt_hmac_sha256.h</code>: HMAC SHA256 functions,</li> <li><code>lt_x25519.h</code>: Curve25519 functions.</li> </ul> <p>Look into each header \u2014 the exact purpose of every function is described in its comment. Copy the function declarations from the headers to the source files and implement the functions.</p> <p>Example</p> <p>To implement Curve25519 functions, copy declarations from <code>lt_x25519.h</code> to <code>lt_mycrypto_x25519.c</code> and provide implementations.</p> </li> <li> <p>Inside <code>cal/mycrypto/</code>, create a file <code>libtropic_mycrypto.h</code>. This file should declare the context structure for <code>mycrypto</code>: <pre><code>typedef struct lt_ctx_mycrypto_t {\n    /** @private @brief AES-GCM context for encryption. */\n    // TODO\n    /** @private @brief AES-GCM context for decryption. */\n    // TODO\n    /** @private @brief SHA-256 context. */\n    // TODO\n} lt_ctx_mycrypto_t;\n</code></pre></p> <p>Which Contexts Are Needed?</p> <p>This structure must include all contexts the functions in the CAL might need. The structure will be defined in the user's application and assigned to the <code>crypto_ctx</code> void pointer in the <code>lt_handle_t</code> \u2014 see the Libtropic Bare-Bone Example for more information.</p> </li> <li> <p>Additionally, other source files and headers can be created for the needs of the implementation.</p> </li> </ol>"},{"location":"for_contributors/adding_cfp/#create-and-implement-the-cal-cmakeliststxt","title":"Create and Implement the CAL CMakeLists.txt","text":"<p>Inside <code>cal/mycrypto/</code>, create a <code>CMakeLists.txt</code> with the following contents: <pre><code>set(LT_CAL_SRCS\n    ${CMAKE_CURRENT_SOURCE_DIR}/lt_mycrypto_common.c    \n    ${CMAKE_CURRENT_SOURCE_DIR}/lt_mycrypto_aesgcm.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/lt_mycrypto_sha256.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/lt_mycrypto_hmac_sha256.c\n    ${CMAKE_CURRENT_SOURCE_DIR}/lt_mycrypto_x25519.c\n    # Other source files if needed\n)\n\nset(LT_CAL_INC_DIRS\n    ${CMAKE_CURRENT_SOURCE_DIR}\n    # Other include directories if needed\n)\n\n# export generic names for parent to consume\nset(LT_CAL_SRCS ${LT_CAL_SRCS} PARENT_SCOPE)\nset(LT_CAL_INC_DIRS ${LT_CAL_INC_DIRS} PARENT_SCOPE)\n</code></pre></p>"},{"location":"for_contributors/adding_cfp/#provide-some-information-about-the-cal","title":"Provide Some Information About the CAL","text":"<p>All currently supported CFPs are listed in the Supported Cryptographic Functionality Providers section. Add the new CFP there and provide some information about it and the CAL (see other sections for inspiration).</p>"},{"location":"for_contributors/adding_host_platform/","title":"Adding a New Host Platform","text":"<p>Libtropic is written to be platform-independent, so no changes to the main code base are needed when adding support for a new host platform. However, to define how communication on the L1 Layer will work, a new Hardware Abstraction Layer (HAL) must be implemented. Currently available HALs are located in <code>hal/</code>.</p>"},{"location":"for_contributors/adding_host_platform/#guide","title":"Guide","text":"<p>This guide will walk you through adding support for a new platform. In this guide, we will add a support for a microcontroller called <code>my_mcu</code> on a board <code>my_board</code>. The directory structure will be different if you create a port e.g., for an operating system. In that case, please get inspired by existing ports (POSIX, Linux).</p> <p>To add support for a our new platform (<code>my_board</code> with <code>my_mcu</code>):</p> <ol> <li>Create and Implement the HAL C Files,</li> <li>Create and Implement the HAL CMakeLists.txt,</li> <li>Provide Some Information About the HAL.</li> </ol> <p>Get Inspired by Existing HALs</p> <p>For inspiration, see the existing HALs inside <code>hal/</code>.</p> <p>After these steps, the sources and include directories of the new HAL should be available in consumer's <code>CMakeLists.txt</code> by calling: <pre><code>add_subdirectory(\"&lt;path_to_libtropic&gt;/hal/my_mcu/my_board\")\n</code></pre></p> <p>By doing this, the CMake variables <code>LT_HAL_SRCS</code> and <code>LT_HAL_INC_DIRS</code> will become available to the consumer.</p>"},{"location":"for_contributors/adding_host_platform/#create-and-implement-the-hal-c-files","title":"Create and Implement the HAL C Files","text":"<ol> <li> <p>Inside <code>hal/</code>, create a new directory called <code>my_mcu</code>.</p> <p>Note</p> <p>The <code>my_mcu/</code> directory inside <code>hal/</code> might already exist, so you do not have to create a new one \u2014 just use the existing one (e.g. <code>stm32</code>).</p> </li> <li> <p>Inside <code>hal/my_mcu/</code>, create a directory called <code>my_board</code>. This is where the implementation will go.</p> </li> <li>Inside <code>hal/my_mcu/my_board/</code>, create the following files:<ul> <li><code>libtropic_port_my_mcu_my_board.h</code>,</li> <li><code>libtropic_port_my_mcu_my_board.c</code>.</li> </ul> </li> <li> <p>Inside <code>libtropic_port_my_mcu_my_board.h</code>, declare:</p> <ol> <li> <p>A new device structure with public and private members in the following way: <pre><code>typedef struct lt_dev_my_mcu_my_board_t {\n    // Public part\n    /** @brief @public first public member comment */\n    // ...\n    /** @brief @public n-th public member comment */\n\n    // Private part\n    /** @brief @private first private member comment */\n    // ...\n    /** @brief @private n-th pivate member comment */\n} lt_dev_my_mcu_my_board_t;\n</code></pre></p> <p>Which Members Are Needed?</p> <p>These members are usually physical pin numbers, SPI handles, or other information needed in the HAL functions that handle the platform-specific interface on the L1 Layer.</p> </li> <li> <p>Additional macros or types you will need in <code>libtropic_port_my_mcu_my_board.c</code>.</p> </li> </ol> </li> <li> <p>Inside <code>libtropic_port_my_mcu_my_board.c</code>, implement all functions declared in <code>include/libtropic_port.h</code>. All of the port functions have an instance of <code>lt_l2_state_t</code> as one of the parameters, where your instance of <code>lt_dev_my_mcu_my_board_t</code> will be saved, so you can get it in a following way: <pre><code>// one of the functions from include/libtropic_port.h\nlt_ret_t lt_port_spi_csn_high(lt_l2_state_t *s2)\n{\n    lt_dev_my_mcu_my_board_t *device =\n        (lt_dev_my_mcu_my_board_t *)(s2-&gt;device);\n\n    // Your implementation ...\n\n    return LT_OK;\n}\n</code></pre></p> <p>Implementation of <code>lt_port_random_bytes</code></p> <p>This function should use some cryptographically secure mechanism to generate the random bytes. Its speed should not be a concern, as this function is not called often.</p> </li> <li> <p>Additionally, other source files and headers can be created for the needs of the implementation.</p> </li> </ol>"},{"location":"for_contributors/adding_host_platform/#create-and-implement-the-hal-cmakeliststxt","title":"Create and Implement the HAL CMakeLists.txt","text":"<p>Inside <code>hal/my_mcu/my_board/</code>, create a <code>CMakeLists.txt</code> with the following contents: <pre><code>set(LT_HAL_SRCS\n    ${CMAKE_CURRENT_SOURCE_DIR}/libtropic_port_my_mcu_my_board.c\n    # Other source files if needed\n)\n\nset(LT_HAL_INC_DIRS\n    ${CMAKE_CURRENT_SOURCE_DIR}\n    # Other include directories if needed\n)\n\n# export generic names for parent to consume\nset(LT_HAL_SRCS ${LT_HAL_SRCS} PARENT_SCOPE)\nset(LT_HAL_INC_DIRS ${LT_HAL_INC_DIRS} PARENT_SCOPE)\n</code></pre></p>"},{"location":"for_contributors/adding_host_platform/#provide-some-information-about-the-hal","title":"Provide Some Information About the HAL","text":"<p>All currently supported host platforms are listed in the Supported Host Platforms section. Add the new host platform there and provide some information about it and the HAL (see other sections for inspiration).</p>"},{"location":"for_contributors/building_documentation/","title":"Building the Documentation","text":"<p>Libtropic documentation is built using the two following frameworks, each building a different part of the documentation:</p> <ol> <li>MkDocs, used to generate the pages you are seeing right now,</li> <li>Doxygen, used to generate the API Reference from the Libtropic source code.</li> </ol> <p>Normally, you should not need to build the documentation yourself - it is available on our GitHub Pages, where versions for all releases are automatically built and released by our GitHub Actions. However, in the case of contributing to the documentation, it is handy to be able to build it locally and preview the new changes. Refer to the following sections for steps on how to do that.</p>"},{"location":"for_contributors/building_documentation/#install-the-dependencies","title":"Install the Dependencies","text":"<p>Installing dependencies</p> <p>First, instal MkDocs dependencies:</p> <ol> <li>Install Python 3, at least version 3.8.</li> <li>We recommend creating a Python Virtual Environment, for example with a name <code>.docs-venv</code>: <pre><code>python3 -m venv .docs-venv\nsource .docs-venv/bin/activate\n</code></pre></li> <li>Update <code>pip</code> and install the needed <code>pip</code> packages using <code>docs/requirements.txt</code>: <pre><code>pip install --upgrade pip\npip install -r docs/requirements.txt\n</code></pre></li> </ol> <p>After that, install Doxygen and Graphviz (used for the diagrams) - installation depends on your system, but we will use Ubuntu in this example: <pre><code>sudo apt-get install doxygen graphviz\n</code></pre></p>"},{"location":"for_contributors/building_documentation/#build-doxygen-documentation","title":"Build Doxygen Documentation","text":"<p>First, the API Reference has to be built using Doxygen:</p> <p>Building Doxygen Documentation</p> <ol> <li>Switch to <code>docs/doxygen/</code>: <pre><code>cd docs/doxygen/\n</code></pre></li> <li>Build: <pre><code>doxygen Doxyfile.in\n</code></pre></li> </ol> <p>The API Reference should be now built in <code>docs/doxygen/build/html/</code>.</p> <p>Warning</p> <p>These steps have to be done each time the contents of <code>docs/doxygen/</code> change and you want to preview the changes.</p>"},{"location":"for_contributors/building_documentation/#build-mkdocs-documentation","title":"Build MkDocs Documentation","text":"<p>MkDocs has the ability to run a builtin development server on localhost, where the documentation is automatically deployed. To run it, switch to the root Libtropic directory, where <code>mkdocs.yml</code> is located, and do:</p> <p>Building MkDocs Documentation</p> <p><pre><code>mkdocs serve\n</code></pre> In the terminal, you should see the address of the server. To open it in your browser, press Ctrl +  Left Click or just manually copy it.</p> <p>Warning</p> <p>MkDocs does not rebuilt the Doxygen documentation automatically - to rebuild it, repeat the steps from section Build Doxygen Documentation.</p> <p>Tip</p> <p>Each time you edit some files inside <code>docs/</code>, the server does not have to be stopped and run again - the server content will be automatically reloaded on each file save.</p>"},{"location":"for_contributors/building_documentation/#versioned-documentation","title":"Versioned Documentation","text":"<p>When you build the documentation using the steps from the section Build MkDocs Documentation, the version selector in the page header is not visible as it is on our GitHub Pages. That is because for the versioning, we use the mike plugin for MkDocs. This plugin maintains the <code>gh-pages</code> branch, from which the GitHub Pages are deployed.</p>"},{"location":"for_contributors/building_documentation/#preview-the-versioned-documentation","title":"Preview the Versioned Documentation","text":"<p>The most common and safe use case is to locally preview the state of the documentation that is deployed to our GitHub Pages:</p> <p>Previewing the Versioned Documentation</p> <ol> <li>Make sure you have the latest version of the <code>gh-pages</code> branch from <code>origin</code>: <pre><code>git fetch origin\ngit pull origin gh-pages\n</code></pre> Do not <code>git checkout gh-pages</code>, because you will not be able to build the documentation there. Do <code>git checkout</code> with <code>master</code>, <code>develop</code> or any other branch based from one of these.</li> <li>Run a builtin development server with the contents of <code>gh-pages</code>: <pre><code>mike serve\n</code></pre></li> </ol> <p>In the terminal, you should see the address of the server. To open it in your browser, press Ctrl +  Left Click or just manually copy it.</p>"},{"location":"for_contributors/building_documentation/#edit-the-versioned-documentation","title":"Edit the Versioned Documentation","text":"<p>Danger</p> <p>Some of the following commands change the state of the local <code>git</code> repository, specifically the <code>gh-pages</code> branch, and possibly the <code>origin</code> remote!</p> <p>If you need to locally deploy a new version and preview it, you have to modify the <code>gh-pages</code> branch:</p> <p>Locally Deploying a New Version</p> <p><pre><code>mike deploy &lt;version_name&gt;\n</code></pre> After running this, <code>gh-pages</code> branch will be created (if it does not already exist) and the generated documentation will be pushed to it.</p> <p>Danger</p> <p>If you add the <code>--push</code> flag, the <code>gh-pages</code> branch will be pushed to <code>origin</code> - we do not recommend doing that! This applies to most of the <code>mike</code> commands.</p> <p>To see all existing versions, do:</p> <p>Seeing Existing Versions</p> <pre><code>mike list\n</code></pre> <p>Info</p> <p>This command is safe - it does not change <code>gh-pages</code> branch.</p> <p>To remove a specific version, do:</p> <p>Deleting Existing Version</p> <pre><code>mike delete\n</code></pre> <p>There are more commands available - refer to the mike repository for more information.</p>"},{"location":"for_contributors/contributing_guide/","title":"Contributing Guide","text":"<p>We love contributions! To make contributing simple for both sides, please:</p> <ul> <li>Open an issue and describe how you would like to contribute and discuss details with us.</li> <li>Create a branch from the develop branch and do the changes:<ul> <li>Make sure to follow specifics in our Coding Style.</li> <li>Make sure to use Code Formatter, otherwise the PR check will fail and cannot be merged.</li> <li>Make sure the branch passes Tests against model -- otherwise, the PR check will fail.</li> <li>Make sure to run Static Analysis.</li> <li>Make sure your Commit Messages follow our guidelines.</li> </ul> </li> <li>Create pull request.</li> </ul>"},{"location":"for_contributors/contributing_guide/#coding-style","title":"Coding Style","text":""},{"location":"for_contributors/contributing_guide/#structures-and-enums","title":"Structures and Enums","text":"<p>In the public API (<code>include/</code>), we define structured types and enumerations using <code>typedef</code>. We do NOT omit structure (enum) name, to keep possibility to declare using <code>struct</code>/<code>enum</code> keywords. Example:</p> <pre><code>typedef struct my_struct {\n    ...\n} my_struct;\n\ntypedef enum my_enum {\n    ...\n} my_enum;\n</code></pre> <p>Anywhere else, we do not use typedefs.</p>"},{"location":"for_contributors/contributing_guide/#code-formatter","title":"Code Formatter","text":"<p>We use the <code>clang-format</code> tool for code formatting. Its installation varies dependening on the linux distribution. </p> <p>Important</p> <p>We recommend using version 16 or higher.</p> <p>To check if <code>clang-format</code> is available on your machine, run: <pre><code>clang-format --version\n</code></pre></p> <p>We use <code>clang-format</code> to check code format on pushes and PRs into the master and develop branches - this is implemented in the action <code>.github/clang_format_check.yml</code>. It only checks the format and does not fix it - that is the contributor's responsibility.</p>"},{"location":"for_contributors/contributing_guide/#how-to-use-it","title":"How to Use It","text":"<p>There are multiple ways to format the code using <code>clang-format</code>:</p> <ol> <li>For each file with wrong formatting, run: <pre><code>clang-format -i &lt;path_to_the_file_to_format&gt;\n</code></pre></li> <li>If you are using VSCode and the <code>cpptools</code> extension, you can create <code>.vscode/settings.json</code> with the following contents (if it does not already exist): <pre><code>{ // Add this bracket only if your settings.json file is empty\n    \"[c]\": {\n        \"editor.defaultFormatter\": \"ms-vscode.cpptools\",\n        \"editor.formatOnSave\": true\n    },\n    \"[cpp]\": {\n        \"editor.defaultFormatter\": \"ms-vscode.cpptools\",\n        \"editor.formatOnSave\": true\n    },\n    \"C_Cpp.formatting\": \"clangFormat\"\n} // Add this bracket only if your settings.json file is empty\n</code></pre> This will format the file on each save.</li> <li>There is also the <code>git-clang-format</code> tool, which integrates <code>clang-format</code> with <code>git</code>, but we have not used that yet.</li> <li>Possibly other ways...</li> </ol>"},{"location":"for_contributors/contributing_guide/#static-analysis","title":"Static Analysis","text":"<p>To run static analysis, follow these steps:</p> <ol> <li>Choose a static analysis tool (e.g., cppcheck, clang-tidy).</li> <li>Configure the tool to analyze the library code.</li> <li>Run the analysis and review the reported issues.</li> </ol>"},{"location":"for_contributors/contributing_guide/#commit-messages","title":"Commit Messages","text":"<p>Our commit message format is inspired by Conventional Commits guidelines.</p> <p>The commit messages should fulfill the following: <pre><code>&lt; type &gt;[ optional scope ]: &lt; description &gt;\n[ optional JIRA REF ]\n[ optional body ]\n[ optional footer ( s ) ]\n</code></pre></p> <p>Where the meaning of individual \ufb01elds is:</p> <pre><code>&lt;type&gt; - Type of commit. Can be one of following:\n    - feat     - A new feature.\n    - build    - A change to build or compile scripts.\n    - ci       - A change to continuous integration setup and scripting.\n    - doc      - A change to documentation.\n    - refactor - A refactoring of code. Shall not change functionality.\n    - test     - A change in tests or test-bench environment.\n    - \ufb01x       - Fix of incorrect functionality.\n    - perf     - Performance enhancement.\n    - deps     - A change to dependency settings\n\n&lt;description&gt;  - Part of the repository or \ufb02ow where the change is made. The \ufb01rst line of the commit message shall be at most 72 characters long.\n\nscope          - Optional part of the repository or \ufb02ow where the change is made.\n\nJIRA REF       - Optional reference to a JIRA issue\n\nbody           - Optional arbitrary number of paragraphs describing what the commit does.\n\nfooter         - Optional footer (see https://www.conventionalcommits.org/en/v1.0.0/#specification)\n</code></pre>"},{"location":"for_contributors/tests/","title":"Tests","text":"<p>We implement two groups of tests:</p> <ul> <li>Functional (which use the standard HAL),</li> <li>Functional Mock (which use the mock HAL).</li> </ul> <p>Functional tests are compatible with all standard HALs and are used to test Libtropic implementation on both model and real hardware host platforms.</p> <p>Functional mock tests are used with mock HAL which allows us to mock communication at the lowest level. They are useful to test functionality not easily triggered on neither model nor the real TROPIC01 chips, such as rare error codes and other special conditions.</p> <p>We also support measuring combined code coverage of both groups: see Code Coverage.</p>"},{"location":"for_contributors/tests/code_coverage/","title":"Code Coverage","text":"<p>We use two groups of tests: functional (which use the standard HAL) and functional mock (which use the mock HAL only).</p> <p>To measure total code coverage from both functional and functional mock tests, combine the coverage data. First, run tests with coverage for each group separately using the guides below.</p> <p>Implementation remarks</p> <ul> <li>We do not measure HAL coverage currently, because not all platforms support coverage collection.</li> <li>CAL is also excluded from coverage collection because we cannot mock CFP return values, which makes full coverage impossible without unit tests.</li> </ul>"},{"location":"for_contributors/tests/code_coverage/#running-functional-tests-with-coverage-against-model","title":"Running Functional Tests with Coverage against Model","text":"<p>We support collecting coverage only against TROPIC01 Model (refer to this link for preparation instructions).</p> <p>Collecting coverage of Functional Tests</p> <p>Create a <code>build/</code> directory and switch to it: <pre><code>cd tests/functional/model/\nmkdir -p build/\ncd build/\n</code></pre> To activate coverage collection, add the switch <code>-DLT_TEST_COVERAGE=1</code> when invoking <code>cmake</code>: <pre><code>cmake -DLT_TEST_COVERAGE=1 -DLT_CAL=\"mbedtls_v4\" ..\nmake\nctest -V\n</code></pre></p> <p>After CTest finishes, use gcovr to export results: <pre><code># Execute this from the tests/functional/model/build/ directory!\ngcovr --json coverage_trace.json --exclude '.*_deps/.*|.*cal/.*|.*hal/.*' -r ../../../..\n</code></pre></p>"},{"location":"for_contributors/tests/code_coverage/#running-functional-mock-tests","title":"Running Functional Mock Tests","text":"<p>Run functional mock tests on the same platform you used for the previous tests. The tests can be compiled and run as following:</p> <p>Collecting coverage of Functional Mock Tests</p> <p>Create a <code>build/</code> directory and switch to it: <pre><code>cd tests/functional_mock/\nmkdir -p build/\ncd build/\n</code></pre> To activate coverage collection, add the switch <code>-DLT_TEST_COVERAGE=1</code> when invoking <code>cmake</code>: <pre><code>cmake -DLT_TEST_COVERAGE=1 ..\nmake\nctest -V\n</code></pre></p> <p>After CTest finishes, use gcovr to export results: <pre><code># Execute this from the tests/functional_mock/build/ directory!\ngcovr --json coverage_trace.json --exclude '.*_deps/.*|.*cal/.*|.*hal/.*' -r ../../..\n</code></pre></p>"},{"location":"for_contributors/tests/code_coverage/#merging-and-exporting-total-coverage","title":"Merging and Exporting Total Coverage","text":"<p>Merge results and export in text format:</p> <p>Merging Coverage Results and Exporting to Text Format</p> <p>Execute this from the repository root (or adjust paths accordingly): <pre><code>gcovr --json-add-tracefile tests/functional_mock/build/coverage_trace.json \\\n      --json-add-tracefile tests/functional/model/build/coverage_trace.json \\\n      --txt coverage.txt\n</code></pre></p> <p>Tip: Gcovr Output Formats</p> <p>You can use <code>--html</code> or <code>--html-details</code> output options to export in a HTML format or <code>--markdown</code> to export in a Markdown format instead of <code>--txt</code>. Check out gcovr user guide.</p>"},{"location":"for_contributors/tests/functional_mock_tests/","title":"Functional Mock Tests","text":"<p>Functional Mock Tests run against the mock HAL (not a real target or a model). They are used to verify behavior that is difficult or impossible to reproduce on a real device (for example, rare hardware error conditions or unusual timing). These tests live in <code>tests/functional_mock</code> and require you to explicitly mock the data that would appear on the MISO line.</p>"},{"location":"for_contributors/tests/functional_mock_tests/#compilation-and-running","title":"Compilation and Running","text":"<p>These tests are compiled standalone in the <code>tests/functional_mock</code> directory. The tests can be compiled and run as follows:</p> <p>Compiling and Running Functional Mock Tests</p> <p>Create a <code>build/</code> directory and switch to it: <pre><code>cd tests/functional_mock/\nmkdir -p build/\ncd build/\n</code></pre> Build and run the tests: <pre><code>cmake ..\nmake\nctest -V\n</code></pre></p> <p>Strict Compilation</p> <p>Strict compilation flags are applied by default. It is strongly recommended to develop tests with strict compilation flags enabled. You can disable the flags by passing <code>-DLT_STRICT_COMPILATION=0</code> to <code>cmake</code>.</p>"},{"location":"for_contributors/tests/functional_mock_tests/#debugging","title":"Debugging","text":"<p>We support running tests with GNU Debugger, Valgrind and Address Sanitizer. See Debugging.</p>"},{"location":"for_contributors/tests/functional_mock_tests/#adding-a-new-test","title":"Adding a New Test","text":"<p>Important</p> <p>If possible and feasible, prefer implementing classic functional tests, as they can run on all platforms. Use functional mock tests only to cover behavior that cannot be easily tested on real targets (for example, extremely rare hardware errors) or for tests that do not use any communication at all (typically parameter checking tests).</p>"},{"location":"for_contributors/tests/functional_mock_tests/#basic-concepts","title":"Basic concepts","text":"<p>You must understand three TROPIC01 protocol layers when writing these tests:</p> <ul> <li>L1 \u2014 SPI transfer: a single call to <code>lt_port_spi_transfer</code>. Any number of bytes can be sent/received in one transfer.</li> <li>L2 \u2014 Frame: started by CSN falling edge and ended by CSN rising edge. A frame may be delivered in one L1 transfer or across multiple L1 transfers (sending byte-by-byte is allowed while CSN is low).</li> <li>L3 \u2014 Packet: a logical packet carried inside L2 frames' REQ_DATA/RSP_DATA. L3 packets can be split across several L2 frames.</li> </ul> <p>Key practical points and rules</p> <ul> <li>SPI always exchanges bytes: every transfer swaps master's and slave's data. For the mock HAL you should mock the MISO side (what the chip would send back). MOSI (what host \u2014 Libtropic \u2014 sends) is ignored by the current mock implementation.</li> <li>We distinguish a host \"read\" vs \"write\" only by the packet <code>REQ_ID</code>. Frames with <code>REQ_ID == Get_Response (0xAA)</code> are treated as reads (the host expects complete frame on MISO). All other REQ_IDs are requests; the chip normally answers those with a single <code>CHIP_STATUS</code> byte.</li> <li>Mocked data are queued as L2 frames \u2014 not as individual bytes. After a CSN rising edge the next queued mocked frame becomes the source for subsequent MISO bytes.</li> <li>If your code attempts to read more MISO bytes than you queued, the mock HAL returns zeros (up to <code>LT_L1_MAX_LENGTH</code>). This keeps tests simpler but means you should queue the bytes the code will actually read for clarity.</li> <li>If there is no mocked frame in the queue when the test pulls CSN low, the mock HAL reports an error. Any SPI transfer while CSN is high is also an error.</li> </ul> <p>Two common mocked frame shapes</p> <ul> <li>Response frame (for <code>REQ_ID == Get_Response</code>, 0xAA): MISO contains     <code>CHIP_STATUS</code>, <code>STATUS</code>, <code>RSP_LEN</code>, <code>RSP_DATA</code>, <code>RSP_CRC</code>.</li> <li>Request acknowledgement frame (for other <code>REQ_ID</code>s): MISO contains only <code>CHIP_STATUS</code>.</li> </ul> <p>Notes about lengths and CRC</p> <ul> <li>Do not assume <code>sizeof()</code> matches the transmitted length \u2014 some reply structures are overlayed or have variable-length fields. Use the helper <code>calc_mocked_resp_len()</code> (found in the mock helpers) to produce correct mocked lengths including CRC.</li> <li>The CRC bytes may not always sit in a named <code>crc</code> field in the C struct; if the data are shorter the CRC can appear earlier in the layout. Use the <code>add_resp_crc()</code> helper or compute the CRC manually when constructing the frame bytes.</li> </ul>"},{"location":"for_contributors/tests/functional_mock_tests/#secure-session-mocking","title":"Secure Session mocking","text":"<p>We support mocking of Secure Session using several provided helper functions. There are two limitations to be aware of:</p> <ul> <li>No handshake is actually done (between Libtropic and mock HAL), provided helper functions only set up internal state of Libtropic (state flags and encryption).</li> <li>Command encryption key and result encryption key have to match. This is a simplification to be able to use existing CAL interface for both Libtropic and mock HAL purposes without a need to reinitialize AES contexts every time.</li> </ul> <p>There are several helper functions to help you mock the Secure Session:</p> <ul> <li><code>mock_session_start()</code>, which will start a mocked Secure Session,</li> <li><code>mock_l3_command_responses()</code> to mock reply to L3 Command (not the L3 Result yet, just confirmations),</li> <li><code>mock_l3_result()</code> to mock the L3 Result,</li> <li><code>mock_session_abort()</code> to abort mocked Secure Session.</li> </ul> <p>As you can see, there are two functions for mocking replies. Normally, you have to use both. To understand why, you need to understand how the L3 communication works. For example, you will call <code>lt_ping</code>. Let's assume a small payload, so it'll fit into a single chunk. From a communication perspective, Libtropic will:</p> <ol> <li>Write an L2 Request with L3 Command as a payload. It will receive single <code>CHIP_STATUS</code> as a response.</li> <li>Read a confirmation response (using <code>Get_Response</code>) to confirm that the chunk was received OK. It will receive a short frame with <code>STATUS=REQ_OK</code>.</li> <li>After confirmation that the chunk was received OK, Libtropic will send another <code>Get_Response</code> to get the L3 Result itself.</li> </ol> <p>Steps 1. and 2. are mocked using the <code>mock_l3_command_responses()</code>, step 3. using <code>mock_l3_result()</code>.</p> <p>Chunking</p> <p>Commands with large payloads that do not fit into a single chunk are not supported yet, because chunking is not implemented in the mock HAL.</p>"},{"location":"for_contributors/tests/functional_mock_tests/#creating-the-test","title":"Creating the Test","text":"<p>To add a new test, do the following:</p> <ol> <li>Write the test. Add a new file to <code>tests/functional_mock</code> named <code>lt_test_mock_&lt;name&gt;.c</code>. The test must contain an entry-point function with the same name as the file for clarity; this function will be the entry point. You can use the Test Template.</li> <li>Add the declaration and a Doxygen comment to <code>tests/functional_mock/lt_functional_mock_tests.h</code>.</li> <li>Add the test to <code>tests/functional_mock/CMakeLists.txt</code>:<ul> <li>Add the test name to the <code>LIBTROPIC_MOCK_TEST_LIST</code> (it must match the name of the entry-point function).</li> </ul> </li> <li>Make sure your test passes. If it fails, either you made a mistake in the test (fix it) or you found a bug. If you are certain it is a bug and not an issue with your test, open an issue.</li> </ol>"},{"location":"for_contributors/tests/functional_mock_tests/#test-template","title":"Test Template","text":"<p>Change the lines marked with <code>TODO</code>.</p> <pre><code>/**\n * @file TODO: FILL ME\n * @brief TODO: FILL ME\n * @copyright Copyright (c) 2020-2026 Tropic Square s.r.o.\n *\n * @license For the license see file LICENSE.txt file in the root directory of this source tree.\n */\n\n#include \"libtropic.h\"\n#include \"libtropic_common.h\"\n#include \"libtropic_logging.h\"\n#include \"libtropic_port_mock.h\"\n#include \"lt_functional_mock_tests.h\"\n#include \"lt_mock_helpers.h\"\n#include \"lt_test_common.h\"\n\nint lt_test_mock_my_test(lt_handle_t *h)\n{\n    LT_LOG_INFO(\"----------------------------------------------\");\n    LT_LOG_INFO(\"lt_test_mock_my_test()\");\n    LT_LOG_INFO(\"----------------------------------------------\");\n\n    lt_mock_hal_reset(&amp;h-&gt;l2);\n    LT_LOG_INFO(\"Mocking initialization...\");\n    LT_TEST_ASSERT(LT_OK, mock_init_communication(h, (uint8_t[]){0x00, 0x00, 0x00, 0x02}));  // Version 2.0.0\n\n    LT_LOG_INFO(\"Initializing handle\");\n    LT_TEST_ASSERT(LT_OK, lt_init(h));\n\n    // TODO: Put the content of the test here.\n\n    LT_LOG_INFO(\"Deinitializing handle\");\n    LT_TEST_ASSERT(LT_OK, lt_deinit(h));\n\n    return 0;\n}\n</code></pre> <p>Usage of Mock Helpers</p> <p>Refer to already existing tests for examples on mock helpers usage.</p>"},{"location":"for_contributors/tests/functional_tests/","title":"Functional Tests","text":"<p>Functional tests are used to verify the Libtropic core API and are implemented in <code>tests/functional/</code>.  Running functional tests is supported on all platforms, although not all tests are compatible with each platform (see Compatibility). There are CI jobs in Libtropic repository which run the tests against TROPIC01 Model with ASan and Valgrind.</p> <p>The functional tests are organized into two categories, as some of them may cause irreversible changes to the chip:</p> <ul> <li>Reversible (<code>lt_test_rev_*.c</code>): only reversible operations are executed on the TROPIC01.</li> <li>Irreversible (<code>lt_test_ire_*.c</code>): irreversible operations are executed: the state or contents of the TROPIC01 cannot be reverted.</li> </ul>"},{"location":"for_contributors/tests/functional_tests/#compilation-and-running","title":"Compilation and Running","text":"<p>DANGER!</p> <p>Functional tests are for internal use only and are provided only for reference. Some tests can destroy your chip. Do not run the tests unless you use model only or you are absolutely sure what you are doing. If you damage your chip with the tests, we are unable to provide any support.</p> <p>For each supported host platform (HAL), there is a subdirectory in <code>tests/functional/</code>. Tests can be compiled as following (we will use model as an example):</p> <p>Compiling Functional Tests for Model</p> <p>Create a <code>build/</code> directory and switch to it: <pre><code>cd tests/functional/model/\nmkdir build/\ncd build/\n</code></pre> Build the tests for model with Crypto Abstraction Layer (CAL) for MbedTLS: <pre><code>cmake -DLT_CAL=mbedtls_v4 ..\nmake\n</code></pre></p> <p>As you can see, there is one mandatory parameter for selection of the Crypto Abstraction Layer (CAL). See <code>cal/</code> directory for currently supported CALs or just run <code>cmake -DLT_CAL= ..</code> for enumeration of supported options. There are also other options, see Available Options.</p> <p>After compilation is finished, the tests can be run using CTest:</p> <p>Using CTest</p> <p>To see available tests, run: <pre><code>ctest -N\n</code></pre></p> <p>To select specific test(s) using regular expression, run: <pre><code>ctest -R &lt;test_regex&gt;\n</code></pre> where <code>&lt;test_regex&gt;</code> is a regular expression for the test names from the list.</p> <p>To run all reversible tests, simply run: <pre><code>ctest _rev_\n</code></pre></p> <p>To exclude some tests, run: <pre><code>ctest -E &lt;test_regex&gt;\n</code></pre> where <code>&lt;test_regex&gt;</code> is a regular expression for the test names from the list.</p>"},{"location":"for_contributors/tests/functional_tests/#test-logs","title":"Test Logs","text":"<p>Tests on the model output all logging information into separate files in <code>tests/functional/model/build/run_logs/</code>. All other platforms output logging to stdout, which can be redirected either using standard Bash redirection or using CTest options.</p> <p>To enable verbose output from CTest, run <code>ctest -V</code> or <code>ctest -W</code> switch for even more verbose output.</p>"},{"location":"for_contributors/tests/functional_tests/#available-options","title":"Available Options","text":"<p>Options common for all host platforms:</p> Option Description Type Default <code>LT_ASAN</code> Enables static AddressSanitizer boolean OFF <code>LT_CAL</code> Flexible switching between the implemented CALs (Crypto Abstraction Layers) string - <code>LT_STRICT_COMPILATION</code> Enables strict compilation flags boolean ON <code>LT_VALGRIND</code> CTest runs the binaries with Valgrind boolean OFF"},{"location":"for_contributors/tests/functional_tests/#debugging","title":"Debugging","text":"<p>We support running tests with GNU Debugger, Valgrind and Address Sanitizer. See Debugging.</p>"},{"location":"for_contributors/tests/functional_tests/#compatibility","title":"Compatibility","text":"<p>Not all tests are compatible with the model, as it does not implement all of the TROPIC01's functionality. To see which tests are unavailable for the model, simply run <code>ctest -N</code> and compare with the sources or have a look at <code>tests/functional/model/CMakeLists.txt</code>, where the tests are removed using <code>list(REMOVE_ITEM LIBTROPIC_TEST_LIST &lt;list&gt;)</code>.</p>"},{"location":"for_contributors/tests/functional_tests/#adding-a-new-test","title":"Adding a New Test","text":"<p>To add a new test, you need to:</p> <ol> <li>Decide whether the test is reversible or irreversible (see Test Types and Cleanup if you are not sure).</li> <li>Write the new test (see Test Template).</li> <li>Add the declaration together with a Doxygen comment to <code>tests/functional/src/libtropic_functional_tests.h</code>.</li> <li> <p>Add the test to <code>tests/functional/src/CMakeLists.txt</code>:</p> <ul> <li>In the section \"LIBTROPIC FUNCTIONAL TESTS\", add the test name to the <code>LIBTROPIC_TEST_LIST</code> (it must match the name of the function that implements the test)</li> <li>Below the <code>LIBTROPIC_TEST_LIST</code>, there is a section where <code>SDK_SRCS</code> is extended     with test source files. Add your test source file there.</li> <li>Make sure your test works - you can run it against the model. If the test    fails, you either:</li> <li>Did a mistake in the test. Fix it.</li> <li>Or you found a bug - if you are certain it is a bug and not a problem in your test,   open an issue. Thanks!</li> </ul> </li> </ol>"},{"location":"for_contributors/tests/functional_tests/#test-types-and-cleanup","title":"Test Types and Cleanup","text":"<p>As the tests are also ran against the real chips, we recognize two types of tests:</p> <ol> <li>Reversible. This type of test shall not make any irreversible changes to the chip. It may    happen that the test is interrupted by a failed assert. For these cases, there is a possibility    to define a cleanup function, which is called on every failed assert before the test termination.    If the test does some changes to the chip, which should be reverted after the end of the test,    the cleanup function for the test must be implemented, to make the test truly reversible.</li> <li>Irreversible. This type of test causes changes that are not reversible by nature (e.g., I-Config     modifications). These tests do not have to implement a cleanup function, since the chip state or     contents cannot be reverted after the test ends.</li> </ol>"},{"location":"for_contributors/tests/functional_tests/#cleanup-function","title":"Cleanup Function","text":"<p>If an assert fails, the assert function checks whether the <code>lt_test_cleanup_function</code> function pointer is not <code>NULL</code>. If so, the cleanup function is called automatically before terminating the test. By default, the pointer is initialized to <code>NULL</code>.</p> <p>If you need a cleanup function, create the function and assign it to <code>lt_test_cleanup_function</code> at the appropriate point in the test (for example, after you back up data that you will restore later).</p> <p>to duplicate the cleanup code if it would be the same. If you wrap the function call in the <code>LT_TEST_ASSERT</code>, do not forget to set <code>lt_test_cleanup_function</code> back to <code>NULL</code> beforehands, otherwise the cleanup will be called twice. You can reuse your cleanup function at the end of the test so you don't have to duplicate the cleanup code. If you wrap the function call in <code>LT_TEST_ASSERT</code>, remember to set <code>lt_test_cleanup_function</code> back to <code>NULL</code> beforehand, otherwise the cleanup will be called twice.</p>"},{"location":"for_contributors/tests/functional_tests/#test-template","title":"Test Template","text":"<p>Change the lines marked with <code>TODO</code>.</p> <pre><code>/**\n * @file TODO: FILL ME\n * @brief TODO: FILL ME\n * @copyright Copyright (c) 2020-2026 Tropic Square s.r.o.\n *\n * @license For the license see the LICENSE.txt file in the root directory of this source tree.\n */\n\n#include \"libtropic.h\"\n#include \"libtropic_common.h\"\n#include \"libtropic_functional_tests.h\"\n#include \"libtropic_logging.h\"\n\n// Shared with cleanup function.\n// TODO: CAN BE REMOVED IF CLEANUP IS NOT USED.\nlt_handle_t *g_h;\n\n// TODO: REMOVE OR EDIT\nstatic lt_ret_t lt_new_test_cleanup(void)\n{\n    LT_LOG_INFO(\"Starting secure session with slot %d\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0);\n    ret = lt_verify_chip_and_start_secure_session(g_h, LT_TEST_SH0_PRIV, LT_TEST_SH0_PUB, TR01_PAIRING_KEY_SLOT_INDEX_0);\n    if (LT_OK != ret) {\n        LT_LOG_ERROR(\"Failed to establish secure session, ret=%s\", lt_ret_verbose(ret));\n        return ret;\n    }\n\n    // TODO: REST OF THE CLEANUP DUTIES\n\n    return LT_OK;\n}\n\nvoid lt_new_test(lt_handle_t *h)\n{\n    LT_LOG_INFO(\"----------------------------------------------\");\n    LT_LOG_INFO(\"lt_new_test()\");\n    LT_LOG_INFO(\"----------------------------------------------\");\n\n    // TODO/NOTE: If you use cleanup, do not forget to assign handle to a globally available pointer,\n    // so you can use the handle in the cleanup function.\n    g_h = h;\n\n    LT_LOG_INFO(\"Initializing handle\");\n    LT_TEST_ASSERT(LT_OK, lt_init(h));\n\n    LT_LOG_INFO(\"Starting secure session with key %d\", (int)TR01_PAIRING_KEY_SLOT_INDEX_0);\n    LT_TEST_ASSERT(LT_OK, lt_verify_chip_and_start_secure_session(h, LT_TEST_SH0_PRIV, LT_TEST_SH0_PUB, TR01_PAIRING_KEY_SLOT_INDEX_0));\n    LT_LOG_LINE();\n\n    // TODO: DO THE TESTING HERE\n    // Add this line if you need cleanup. Add it where appropriate -- e.g. after backing up data\n    // you need to restore in the cleanup.\n    lt_test_cleanup_function = &amp;lt_new_test_cleanup;\n\n    // Call cleanup function, but don't call it from LT_TEST_ASSERT anymore.\n    lt_test_cleanup_function = NULL;\n    LT_LOG_INFO(\"Starting post-test cleanup\");\n    LT_TEST_ASSERT(LT_OK, lt_new_test_cleanup());\n    LT_LOG_INFO(\"Post-test cleanup was successful\");\n}\n</code></pre>"},{"location":"for_contributors/tests/functional_tests/#advanced-and-troubleshooting","title":"Advanced and Troubleshooting","text":""},{"location":"for_contributors/tests/functional_tests/#running-a-test-with-your-own-pairing-key","title":"Running a Test With Your Own Pairing Key","text":"<p>If you have already written your own public key to one of the available slots and want to execute a test that uses a Secure Session, define the arrays for your private and public key as globals and, after <code>#include \"lt_test_common.h\"</code>, do the following:</p> <pre><code>#undef LT_TEST_SH0_PRIV\n#define LT_TEST_SH0_PRIV &lt;var_name_with_your_private_pairing_key&gt;\n\n#undef LT_TEST_SH0_PUB\n#define LT_TEST_SH0_PUB &lt;var_name_with_your_public_pairing_key&gt;\n</code></pre>"},{"location":"for_contributors/tests/functional_tests/#cannot-establish-a-secure-session","title":"Cannot Establish a Secure Session","text":"<p>Refer to a dedicated section in the FAQ.</p>"},{"location":"reference/","title":"Reference","text":"<p>This section provides all necessary information about Libtropic and other related things.</p> <ul> <li>Libtropic Architecture</li> <li>Integrating Libtropic</li> <li>TROPIC01 Firmware</li> <li>Default Pairing Keys for a Secure Channel Handshake</li> <li>Logging</li> <li>Debugging</li> </ul>"},{"location":"reference/debugging/","title":"Debugging","text":"<p>When debugging, some additional compiler flags are needed to produce debugging information. These flags can be enabled using CMake's <code>CMAKE_BUILD_TYPE</code> option. This option can be set similarly as the Libtropic's CMake options \u2014 see How to Configure section.</p> <p>After this, you can use debugging tools of your choice, e.g. GNU Debugger or Valgrind. Refer to each tool's documentation for installation instructions.</p>"},{"location":"reference/debugging/#debugging-the-tests","title":"Debugging the Tests","text":"<p>In our functional and functional mock tests we support running with both AddressSanitizer and Valgrind on Linux (USB, SPI and model HALs):</p> <ul> <li>To use AddressSanitizer: add CMake switches <code>-DCMAKE_BUILD_TYPE=Debug</code> and <code>-DLT_ASAN=1</code>.</li> <li>To use Valgrind: add CMake switches <code>-DCMAKE_BUILD_TYPE=Debug</code> and <code>-DLT_VALGRIND=1</code>.</li> </ul> <p>You can also use GNU Debugger to debug the tests:</p> <ul> <li>Add CMake switch <code>-DCMAKE_BUILD_TYPE=Debug</code> and run the binary using <code>gdb</code>.<ul> <li>If you want to use the debugger with the model, you can't use the model runner. Run the model server manually instead and then run the test binary using <code>gdb</code>. See the model tutorial.</li> </ul> </li> </ul> <p>Not sure if ASan or Valgrind is working?</p> <p>Paste one of the following snippets to a source file where you want to check the error detection.</p> <pre><code>char *p = malloc(10);\nif (!p) return 1;\np[10] = 'X'; // one-past-end heap buffer write -&gt; ASan/Valgrind should report\nfree(p);\n</code></pre> <pre><code>char *p = malloc(16);\nif (!p) return 1;\nfree(p);\np[0] = 'X'; // use-after-free -&gt; ASan/Valgrind should report\n</code></pre>"},{"location":"reference/default_pairing_keys/","title":"Default Pairing Keys for a Secure Channel Handshake","text":"<p>To establish a Secure Channel Session with TROPIC01, one of the Pairing Key slots has to be written with an X25519 public key (refered to as \\(S_{HiPUB}\\), where \\(i\\) is the i-th slot). The entity, which is about to establish the Secure Channel Session with TROPIC01, has to own the corresponding X25519 private key (refered to as \\(S_{HiPRIV}\\)).</p> <p>At the time of manufacturing, Tropic Square configures the Pairing Key slot 0 of every TROPIC01 with \\(S_{H0PUB}\\), generated from \\(S_{H0PRIV}\\), which is provided to customers. The customer can then establish a Secure Channel Session with Pairing Key slot 0, configure TROPIC01, write their own X25519 public key to slot 1, 2 or 3 and invalidate the slot 0 (which is recommended for security reasons).</p> <p>More Information About Pairing Keys</p> <p>For more information, refer to the TROPIC01 datasheet.</p>"},{"location":"reference/default_pairing_keys/#default-pairing-keys-in-libtropic","title":"Default Pairing Keys in Libtropic","text":"<p>Libtropic provides both of these default \\(S_{H0PUB}\\) and \\(S_{H0PRIV}\\) keys by including <code>libtropic_common.h</code>:</p> <ol> <li>arrays <code>sh0pub_prod0</code> and <code>sh0priv_prod0</code> - production keys found in the majority of distributed TROPIC01 chips (see Available Parts table in the TROPIC01 GitHub repository for P/N values),</li> <li>arrays <code>sh0pub_eng_sample</code> and <code>sh0priv_eng_sample</code> - keys found in engineering (pre-production) samples of TROPIC01 with P/N <code>TROPIC01-ES</code>.</li> </ol>"},{"location":"reference/default_pairing_keys/#establishing-your-first-secure-channel-session","title":"Establishing Your First Secure Channel Session","text":"<p>To establish a Secure Channel Session with your new TROPIC01, do the following:</p> <ol> <li>Get P/N of your TROPIC01 \u2014 refer to FAQ.</li> <li> <p>Establish the Secure Channel Session:</p> <p>There are two options, depending on what you want to do \u2014 choose one:</p> <ol> <li>You want to run our examples (see Tutorials) that establish a Secure Channel Session:<ol> <li>Your P/N is <code>TROPIC01-ES</code> -&gt; Set <code>LT_SH0_KEYS</code> CMake option to <code>\"eng_sample\"</code>.</li> <li>Your P/N is not <code>TROPIC01-ES</code> -&gt; nothing has to be done, the production keys are used by default.</li> </ol> </li> <li> <p>You are writing your own application -&gt; select the correct key pair arrays according to Default Pairing Keys in Libtropic and simply pass them to either:</p> <ol> <li><code>lt_verify_chip_and_start_secure_session</code> helper function, or</li> <li><code>lt_session_start</code> core API function.</li> </ol> <p>Refer to the API Reference for more information about these functions.</p> </li> </ol> </li> </ol>"},{"location":"reference/libtropic_architecture/","title":"Libtropic Architecture","text":"<p>Before you learn about Libtropic's architecture, it is important to understand the communication between the host MCU and TROPIC01. Both parties communicate via a multi-layer serial protocol consisting of the following three layers:</p> <ol> <li>Physical Layer (L1). A transfer is a unit of communication and a 4-wire SPI interface is used.</li> <li>Data Link Layer (L2). A frame is a unit of communication that is organized into multiple fields. During L2 communication, the host MCU sends an L2 Request frame and TROPIC01 returns an L2 Response frame. Communication on the L2 Layer is not encrypted and is used for non-secure information about TROPIC01 and for setting up L3 communication.</li> <li>Secure Session Layer (L3). A packet is a unit of communication. L3 communication requires an established Secure Channel Session. Once established, the host MCU can communicate by sending L3 Command packets and TROPIC01 responds with L3 Result packets. The communication is executed on an encrypted channel (Secure Channel) with strong forward secrecy based on the Noise Protocol Framework.</li> </ol> <p>For more information about TROPIC01, please refer to TROPIC01 repository.</p> <p>Libtropic's architecture is visualized in the following figure:</p>      Libtropic Architecture    <p>Libtropic consists of:</p> <ol> <li>Libtropic Public API. Macros and data structures are available in <code>include/libtropic_common.h</code> and function declarations are in <code>include/libtropic.h</code> (implemented in <code>src/libtropic.c</code>). The interface of these functions is tightly related to TROPIC01's commands, defined in the User API (see the TROPIC01 repository). These public functions are used for unencrypted communication via the Layer 2 API, and encrypted communication via the Layer 3 API.</li> <li>Helpers. Functions also declared in <code>include/libtropic.h</code> that either wrap one or more Libtropic API functions to simplify operations (e.g. <code>lt_verify_chip_and_start_secure_session()</code> for easier Secure Session establishment), or provide additional functionality (e.g. <code>lt_print_chip_id()</code> for interpreting and printing TROPIC01's <code>CHIP_ID</code>).</li> <li>Examples. Demonstrate usage of Libtropic in Tutorials, using both the Libtropic API and Helpers.</li> <li>Functional Tests. Used to verify the Libtropic core API using both the Libtropic API and Helpers.</li> <li>L3 Layer API. Functions called by the Libtropic Public API during encrypted communication. Because the L3 Layer requires cryptographic functionality (for example, to decrypt incoming L3 Result packets from TROPIC01), it uses a Crypto Abstraction Layer (CAL) to obtain functionality provided by a Cryptographic Functionality Provider (CFP). A CFP can be a cryptographic library (e.g. MbedTLS) or a cryptographic hardware accelerator. The CAL is declared in headers inside <code>src/</code> and specific CAL implementations for each CFP exist in <code>cal/</code>. It is assumed that only one CAL implementation is used for a given Libtropic build.</li> <li>L2 Layer API. Functions called by the Libtropic Public API during Unencrypted Communication.</li> <li>L1 Layer API. Functions called by the L2 Layer API that wrap port-specific L1 Layer functions implemented by the Hardware Abstraction Layers (HAL) in <code>hal/</code>. These HALs are initialized using the Libtropic Public API. The library can be compiled with support for only one HAL at a time, but a single HAL may support communication with multiple chips.</li> </ol> <p>More Information About Libtropic Functions</p> <p>For more information about Libtropic functions, refer to the API Reference.</p>"},{"location":"reference/logging/","title":"Logging","text":"<p>Libtropic contains a logging functionality, which is disabled by default.</p> <p>You may find it useful to enable logging during Libtropic evaluation or integration. There are five logging levels:</p> <ul> <li>None (default unless compiling tests or examples),</li> <li>Error,</li> <li>Warning,</li> <li>Info,</li> <li>Debug.</li> </ul> <p>One of these logging levels can be switched on using the LT_LOG_LVL CMake option (refer to How to Configure section for ways to set it).</p>"},{"location":"reference/logging/#how-to-log","title":"How to Log","text":"<p>Logging can be done using logging macros, which are defined in <code>include/libtropic_logging.h</code>. Following logging macros are available:</p> <ul> <li><code>LT_LOG_INFO</code>,</li> <li><code>LT_LOG_WARN</code>,</li> <li><code>LT_LOG_ERROR</code>,</li> <li><code>LT_LOG_DEBUG</code>.</li> </ul> <p>Each macro corresponds to a verbosity level, which is activated with the aforementioned CMake switch. Macros have the same interface as the <code>printf</code> function, as they are essentially a wrapper over <code>printf</code>.</p> <p>Function Calls as LT_LOG_* Arguments</p> <p>Avoid passing function calls as macro arguments (except for simple formatting helpers like <code>lt_ret_verbose</code> or <code>strerror</code>). Logging macros may be completely removed at lower verbosity levels, meaning any function calls inside them will not execute.</p> <p>This is safe (using <code>lt_ret_verbose()</code> helper function only):</p> <pre><code>LT_LOG_INFO(\"Error code: %d, error string: %s\", ret, lt_ret_verbose(ret));\n</code></pre> <p>This is unsafe \u2014 <code>lt_init()</code> will never run if logging is disabled:</p> <pre><code>LT_LOG_INFO(\"Initializing handle: %d\", lt_init(&amp;h));\n</code></pre> <p>Correct approach \u2014 call the function first, then log its result:</p> <pre><code>int ret = lt_init(&amp;h);\nLT_LOG_INFO(\"Initializing handle: %d\", ret);\n</code></pre> <p>Other Macros</p> <p>There are also macros used for assertion. These are used in Functional Tests.</p>"},{"location":"reference/provisioning_data/","title":"Provisioning Data","text":"<p>The <code>scripts/tropic01_model/provisioning_data</code> directory contains so-called lab batch packages, which are data used for provisioning TROPIC01 chips in the Tropic Square lab for testing purposes. In Libtropic, these lab batch packages are used for configuring the TROPIC01 Model. </p> <p>Note</p> <p>Lab batch packages in this directory are stripped \u2014 they contain only the data needed by Libtropic.</p>"},{"location":"reference/provisioning_data/#lab-batch-package-contents","title":"Lab Batch Package Contents","text":"<p>For example, the <code>2025-06-27T07-51-29Z__prod_C2S_T200__provisioning__lab_batch_package/</code> lab batch package:</p> <ol> <li><code>cert_chain/</code>: All certificates for the Certificate Store (excluding TROPIC01's eSE device certificate, which is originally not part of the lab batch package and can be found outside the <code>cert_chain/</code> directory).</li> <li><code>i_config/</code>, <code>r_config/</code>: Currently unused. Contains fields that should be written.</li> <li><code>sh0_key_pair/</code>: Contains the public and private key for pairing key slot 0 (SH0PUB, SH0PRIV).</li> <li><code>tropic01_ese_certificate.pem</code>: TROPIC01's eSE device certificate.</li> <li><code>tropic01_ese_private_key.pem</code>: TROPIC01's eSE device private key (STPRIV).</li> </ol>"},{"location":"reference/tropic01_fw/","title":"TROPIC01 Firmware","text":"<p>TROPIC01 contains the following FW execution engines:</p> <ul> <li>RISC-V CPU,</li> <li>ECC engine or SPECT (these two terms are used interchangeably).</li> </ul> <p>There are multiple kinds of FW running in TROPIC01:</p> <ol> <li>Immutable FW (bootloader). Located in ROM, runs on RISC-V CPU from ROM after power-up, updates or boots the mutable FWs.</li> <li>RISC-V Mutable FW (CPU FW). Updatable, located in R-memory, runs on RISC-V CPU from RAM, processes L2/L3 communication.</li> <li>ECC engine mutable FW (ECC engine FW or SPECT FW). Updatable, located in R-memory, runs on ECC engine from RAM, helps the RISC-V CPU FW with processing ECC commands (ECC_Key_*, ECDSA/EDDSA_Sign).</li> </ol> <p>More Information About TROPIC01 Firmware</p> <p>For more detailed information about each FW, refer to the FW Update Application Note.</p>"},{"location":"reference/tropic01_fw/#tropic01-firmware-in-libtropic","title":"TROPIC01 Firmware in Libtropic","text":"<p>Libtropic provides not only implementation of the FW update L2 commands, but also the necessary files for updating both the RISC-V and SPECT FW. Refer to:</p> <ol> <li>Firmware Update Files section for more information about the <code>TROPIC01_fw_update_files/</code> directory.</li> <li>Tutorials, where we demonstrate the firmware update feature. Have a look at, for example, Firmware Update on TROPIC01 USB Devkit on Linux.</li> </ol>"},{"location":"reference/tropic01_fw/#firmware-update-files","title":"Firmware Update Files","text":"<p>The <code>TROPIC01_fw_update_files/</code> directory provides TROPIC01 FW update files in two formats:</p> <ol> <li>C header files (<code>*.h</code>). These are designed to be included and compiled directly into the Host MCU's firmware/application. See Compiling into Libtropic section for more information.</li> <li>Binary files (<code>*.bin</code>). These can be stored in the Host MCU's filesystem or external storage, loaded at runtime and used to update TROPIC01's FW.</li> </ol> <p>The general structure of the <code>TROPIC01_fw_update_files/</code> directory is the following: <pre><code>TROPIC01_fw_update_files/\n\u251c\u2500\u2500 boot_v_&lt;X_Y_Z&gt;/\n\u2502   \u2514\u2500\u2500 fw_v_&lt;A_B_C&gt;/\n\u2502       \u251c\u2500\u2500 fw_CPU.h\n\u2502       \u251c\u2500\u2500 fw_SPECT.h\n\u2502       \u251c\u2500\u2500 fw_v&lt;A_B_C&gt;.hex32_signed_chunks.bin\n\u2502       \u2514\u2500\u2500 spect_app-v&lt;D_E_F&gt;_signed_chunks.bin\n\u2514\u2500\u2500 convert.py\n</code></pre></p> <ul> <li><code>boot_v_&lt;X_Y_Z&gt;/</code>: directories of available FW update files for a given bootloader version <code>&lt;X_Y_Z&gt;</code>.</li> <li><code>fw_v_&lt;A_B_C&gt;/</code>: directory with RISC-V CPU and SPECT FW update files (in both formats) for a given FW version <code>&lt;A_B_C&gt;</code>. Note that the RISC-V CPU FW and SPECT FW versions can be different.</li> <li><code>convert.py</code>: Python script for converting firmware binary files into C header files.</li> </ul>"},{"location":"reference/tropic01_fw/#compiling-into-libtropic","title":"Compiling into Libtropic","text":"<p>To select which FW version will be compiled together with Libtropic, the user has to set the following CMake variables (both have a default value):</p> <ul> <li>LT_SILICON_REV,</li> <li>LT_CPU_FW_UPDATE_DATA_VER.</li> </ul>"},{"location":"reference/tropic01_fw/#firmware-hashes","title":"Firmware Hashes","text":"<p>TROPIC01 is able to report hashes of the firmware it is loaded with. Using Libtropic, you can get the value using <code>lt_get_info_fw_bank</code> function.</p> <p>However, for certain old firmware versions, the reported hashes will not match with the hashes found in the public firmware repositories. The reason is that before publication, we cleaned up the git histories. Although the code was not changed, git hashes were affected. Affected version are:</p> <ul> <li>RISC-V CPU FW: versions older than and including v1.0.1.</li> <li>SPECT FW: versions older than and including v1.0.0.</li> </ul> <p>If you want to verify that production binaries match the source code, you can compile the source code and then compare the resulting binary to production binaries provided in the Libtropic repository.</p>"},{"location":"reference/integrating_libtropic/","title":"Integrating Libtropic","text":"<p>This section provides guidance on integrating Libtropic into your application.</p> <ul> <li>How to Build</li> <li>How to Configure</li> <li>How to Use</li> </ul>"},{"location":"reference/integrating_libtropic/how_to_build/","title":"How to Build","text":"<p>Libtropic uses CMake and does not support other build systems by default. However, we provide steps on how to add it to a Makefile project or compile it as a static library.</p> <ul> <li>Add to an Existing Project</li> <li>Compile as a Static Library</li> </ul>"},{"location":"reference/integrating_libtropic/how_to_build/adding_to_project/","title":"Add to an Existing Project","text":"<p>We recommend adding Libtropic to an existing project as a git submodule. Libtropic uses the CMake build system, so it can be added to the compilation of existing CMake projects as follows:</p> <ol> <li>Set path to the Libtropic submodule, for example as: <pre><code>set(PATH_LIBTROPIC ${CMAKE_CURRENT_SOURCE_DIR}/../vendor/libtropic/)\n</code></pre></li> <li>Add the Libtropic subdirectory: <pre><code>add_subdirectory(${PATH_LIBTROPIC} \"libtropic\")\n</code></pre></li> <li>By default, Libtropic does not link a CFP (Cryptographic Functionality Provider) or its CAL (Crypto Abstraction Layer), so it can be built as a static library. This is the consumer's responsibility:<ol> <li>For the chosen CFP (e.g. MbedTLS v4.0.0), add the correct subdirectory inside <code>libtropic/cal/</code>, which provides the corresponding CAL sources and include directories: <pre><code>add_subdirectory(\"${PATH_LIBTROPIC}cal/mbedtls_v4\")\n</code></pre></li> <li>Add the obtained sources and include directories to the <code>tropic</code> target: <pre><code>target_sources(tropic PRIVATE ${LT_CAL_SRCS})\ntarget_include_directories(tropic PUBLIC ${LT_CAL_INC_DIRS})\n</code></pre></li> <li>Link the CFP (provided by the consumer) to the <code>tropic</code> target: <pre><code>target_link_libraries(tropic PUBLIC mbedtls)\n</code></pre></li> </ol> </li> <li>By default, Libtropic does not link platform-specific code or its HAL, so it can be built as a static library. This is the consumer's responsibility:<ol> <li>For the chosen platform (e.g. Linux with HW SPI), add a corresponding HAL using <code>add_subdirectory</code>: <pre><code>add_subdirectory(\"${PATH_TO_LIBTROPIC}hal/linux/spi\")\n</code></pre></li> <li>Add HAL sources and include directories to the <code>tropic</code> target. In the previous step, <code>LT_HAL_SRCS</code> and <code>LT_HAL_INC_DIRS</code> variables were populated based on the selected HAL, so you can use those: <pre><code>target_sources(tropic PRIVATE ${LT_HAL_SRCS})\ntarget_include_directories(tropic PUBLIC ${LT_HAL_INC_DIRS})\n</code></pre></li> </ol> </li> <li>And finally, link Libtropic with your binary: <pre><code>target_link_libraries(my_binary_name PRIVATE tropic)\n</code></pre></li> </ol> <p>Inspiration for CMakeLists.txt</p> <p>The exact CMake calls depend on a configuration of the project into which Libtropic is being added. For more inspiration, refer to our standalone example projects in <code>examples/</code> (explained in Tutorials) and the CMake Documentation.</p> <p>Supported Host Platforms and CFPs</p> <p>Refer to Compatibility section to see what is supported.</p>"},{"location":"reference/integrating_libtropic/how_to_build/adding_to_project/#do-you-use-a-makefile-instead-of-cmake","title":"Do You Use a Makefile Instead of CMake?","text":"<p>If you use a Makefile instead of CMake, you need to:</p> <ol> <li>Manually list all <code>*.c</code> and <code>*.h</code> Libtropic files in your Makefile (you can use the root <code>CMakeLists.txt</code> for inspiration).</li> <li>For each required CMake option <code>&lt;CMAKE_OPTION&gt;</code>, add the <code>-D&lt;CMAKE_OPTION&gt;</code> flag when building with Make.</li> </ol> <p>Available CMake Options</p> <p>See How to Configure for available CMake Options. However, some of these options are not directly used in the Libtropic code - based on them, additional internal macros are defined. To see those, either:</p> <ol> <li>Analyze Libtropic's root <code>CMakeLists.txt</code>.</li> <li>Configure Libtropic using CMake and then execute <code>grep LT_ CMakeCache.txt</code> in your <code>build/</code> directory to see all used options/defines.</li> </ol> <p>Tip: Build Libtropic as a Static Library</p> <p>You can compile Libtropic as a static library (see Compile as a Static Library) using CMake separately and include only the resulting library file in your Makefile. This approach eliminates the need to compile the entire Libtropic library and its dependencies in your Makefile. However, you will still need to manually add the HAL files for your platform (<code>libtropic/hal/</code>) and the CAL files for your CFP (<code>libtropic/cal/</code>).</p>"},{"location":"reference/integrating_libtropic/how_to_build/compile_as_static_library/","title":"Compile as a Static Library","text":"<p>Apart from building Libtropic during your project's build process, you can build Libtropic separately as a static library (also known as a static archive on Linux) and link it later.</p> <p>HAL and CAL Files Handling</p> <p>The Libtropic static library does not contain HALs (<code>libtropic/hal/</code>) or CALs (<code>libtropic/cal/</code>). The consumer must provide these:</p> <ol> <li>If CMake is used, inspiration can be taken from the steps in the Add to an Existing Project section.</li> <li>In other cases, the HAL and CAL files will have to be added manually.</li> </ol>"},{"location":"reference/integrating_libtropic/how_to_build/compile_as_static_library/#compilation","title":"Compilation","text":"<p>Compiling Libtropic as a static library on Unix-like system</p> <p>Create a <code>build/</code> directory and switch to it: <pre><code>mkdir build/\ncd build/\n</code></pre> Build Libtropic: <pre><code>cmake ..\nmake\n</code></pre></p> <p>To cross-compile Libtropic as a static library on a Unix-like system, you need a toolchain configuration file and a linker script. Both should be provided by the vendor of your platform. See an example of the toolchain configuration and linker script e.g. in <code>examples/stm32/hello_world/</code>.</p> <p>Follow these steps after acquiring both the toolchain configuration and the linker script:</p> <p>Cross compiling Libtropic as a static library on a Unix-like system</p> <p>Create a <code>build/</code> directory and switch to it: <pre><code>mkdir build/\ncd build/\n</code></pre> Build Libtropic: <pre><code>cmake -DCMAKE_TOOLCHAIN_FILE=&lt;ABSOLUTE PATH&gt;/toolchain.cmake \\\n      -DLINKER_SCRIPT=&lt;ABSOLUTE PATH&gt;/linker_script.ld ..\nmake\n</code></pre></p>"},{"location":"reference/integrating_libtropic/how_to_build/compile_as_static_library/#linking-in-a-cmake-project","title":"Linking in a CMake Project","text":"<p>To link the compiled static library to your application, use <code>target_link_libraries</code>. For example:</p> <p>Linking a static library in a CMake project</p> <pre><code>add_executable(my_app source1.c source2.c etc.c)\ntarget_link_libraries(my_app &lt;absolute path to library file&gt;)\n</code></pre> <p>Other Linking Options</p> <p>There are other options for linking the library (e.g., imported targets). Refer to the CMake documentation for more information.</p>"},{"location":"reference/integrating_libtropic/how_to_build/compile_as_static_library/#linking-in-a-make-project","title":"Linking in a Make Project","text":"<p>If you are using <code>make</code> with a Makefile, you can include the static library by adding the following lines to your Makefile:</p> <p>Linking Libtropic static library in a Make project</p> <pre><code>LDFLAGS += -L&lt;directory where the static library file is located&gt;\nLDLIBS  += -ltropic\n</code></pre> <p>Linking External Libraries</p> <p>Refer to the GNU Make documentation for more information about linking external libraries.</p>"},{"location":"reference/integrating_libtropic/how_to_configure/","title":"How to Configure","text":"<p>Libtropic can be configured using the Available CMake Options (let's say <code>LT_CFG_OPT</code>) in the following ways:</p> <p>Configuring Libtropic</p> <ol> <li>Via a command line when building the project: <pre><code>cmake -DLT_CFG_OPT=value ..\n</code></pre></li> <li>Using the CMake GUI. This makes the configuring process more user-friendly compared to the previous way. For more information, refer to the cmake-gui documentation.</li> <li>In your project's <code>CMakeLists.txt</code>: <pre><code>set(LT_CFG_OPT value)\n</code></pre></li> </ol>"},{"location":"reference/integrating_libtropic/how_to_configure/#available-cmake-options","title":"Available CMake Options","text":""},{"location":"reference/integrating_libtropic/how_to_configure/#lt_helpers","title":"<code>LT_HELPERS</code>","text":"<ul> <li>boolean</li> <li>default value: <code>ON</code></li> </ul> <p>Compile the helper functions.</p>"},{"location":"reference/integrating_libtropic/how_to_configure/#lt_log_lvl","title":"<code>LT_LOG_LVL</code>","text":"<ul> <li>string</li> <li>default value: <code>\"None\"</code></li> <li>default value if <code>LT_BUILD_EXAMPLES</code> or <code>LT_BUILD_TESTS</code> are set: <code>\"Info\"</code></li> </ul> <p>Specifies the log level. See Logging for more information.</p>"},{"location":"reference/integrating_libtropic/how_to_configure/#lt_use_int_pin","title":"<code>LT_USE_INT_PIN</code>","text":"<ul> <li>boolean</li> <li>default value: <code>OFF</code></li> </ul> <p>Use TROPIC01's interrupt pin while waiting for TROPIC01's response.</p>"},{"location":"reference/integrating_libtropic/how_to_configure/#lt_separate_l3_buff","title":"<code>LT_SEPARATE_L3_BUFF</code>","text":"<ul> <li>boolean</li> <li>default value: <code>OFF</code></li> </ul> <p>Buffer used for sending and receiving L3 Layer data will be defined by the user. The user then has to pass a pointer to their buffer into the instance of <code>lt_handle_t</code>: <pre><code>#include \"libtropic_common.h\"\n\nlt_handle_t handle;\nuint8_t user_l3_buffer[LT_SIZE_OF_L3_BUFF] __attribute__((aligned(16)));\n\nhandle.l3.buff = user_l3_buffer;\nhandle.l3.buff_len = sizeof(user_l3_buffer);\n</code></pre></p>"},{"location":"reference/integrating_libtropic/how_to_configure/#lt_print_spi_data","title":"<code>LT_PRINT_SPI_DATA</code>","text":"<ul> <li>boolean</li> <li>default value: <code>OFF</code></li> </ul> <p>Log SPI communication using <code>printf</code>. Handy to debug low level communication.</p>"},{"location":"reference/integrating_libtropic/how_to_configure/#lt_silicon_rev","title":"<code>LT_SILICON_REV</code>","text":"<ul> <li>string</li> <li>default value: latest silicon revision available in the current Libtropic release</li> </ul> <p>Silicon version (e.g. <code>\"ACAB\"</code>) of the currently used TROPIC01 has to be set in this option. It is needed for TROPIC01's firmware update and functional tests, as some behavior differs between the TROPIC01 revisions.</p> <p>What Is the Silicon Revision of My TROPIC01?</p> <p>Refer to the dedicated section in the FAQ.</p> <p>Warning</p> <p>Because the implementation of Libtropic's FW update functions is chosen at compile-time based on <code>LT_SILICON_REV</code>, in one compiled instance of Libtropic, FW update can be done only with TROPIC01 of this silicon revision.</p> <p>Example</p> <p>I passed <code>-DLT_SILICON_REV=ACAB</code> to <code>cmake</code> during the build. I will be able to do FW updates with TROPIC01 chips that have silicon revision ACAB only. Updating a TROPIC01 chip with e.g. ABAB silicon revision will not work.</p> <p>See Available Values When Using CMake CLI</p> <p>Pass <code>-DLT_SILICON_REV=</code> to <code>cmake</code>, which will invoke an error, but will print the available values.</p>"},{"location":"reference/integrating_libtropic/how_to_configure/#lt_cpu_fw_update_data_ver","title":"<code>LT_CPU_FW_UPDATE_DATA_VER</code>","text":"<ul> <li>string</li> <li>default value: latest FW version available in the current Libtropic release</li> </ul> <p>Defines the TROPIC01's RISC-V CPU FW version (e.g. <code>\"1_0_1\"</code>) to update to. It is used for compiling the correct FW update files for both the RISC-V CPU and SPECT. Available versions can be seen in the compatibility table in the repository's main <code>README.md</code>.</p> <p>See Available Values When Using CMake CLI</p> <p>Pass <code>-DLT_CPU_FW_VERSION=</code> to <code>cmake</code>, which will invoke an error, but will print the available values.</p> <p>See Current Configuration</p> <p>Use <code>cmake -LAH | grep -B 1 LT_</code> to check current value of all Libtropic options.</p>"},{"location":"reference/integrating_libtropic/how_to_use/","title":"How to Use","text":"<p>First, the Host platform and Cryptographic Functionality Provider (CFP) have to be chosen. Refer to sections Supported Host Platforms and Supported Cryptographic Functionality Providers to see which ones are supported.</p>"},{"location":"reference/integrating_libtropic/how_to_use/#which-headers-to-include","title":"Which Headers To Include?","text":"<p>To start using Libtropic in your application, include the following headers:</p> <ol> <li><code>libtropic_common.h</code>: Declarations of commonly used macros, structures, enums, and other definitions.</li> <li><code>libtropic.h</code>: Main API function declarations.</li> <li><code>libtropic_port_&lt;port_name&gt;.h</code>: Declares the <code>lt_dev_&lt;port_name&gt;_t</code> device structure specific to the Host platform (see the <code>libtropic/hal/</code> directory for existing platform HALs). An <code>lt_dev_&lt;port_name&gt;_t</code> variable must be declared and passed to an instance of <code>lt_handle_t</code> (see the example below).</li> <li><code>libtropic_&lt;cfp_name&gt;.h</code>: Declares the <code>lt_ctx_&lt;cfp_name&gt;_t</code> context structure specific to the used CFP (Cryptographic Functionality Provider). See the <code>libtropic/cal/</code> directory for the existing CALs (Crypto Abstraction Layers). An <code>lt_ctx_&lt;cfp_name&gt;_t</code> variable must be declared and passed to an instance of <code>lt_handle_t</code> (see the example below).</li> <li>Based on the needed functionality, include additional headers from <code>libtropic/include/</code>. Refer to the API Reference for more details.</li> </ol> <p>Note</p> <p>The headers <code>libtropic_port_&lt;port_name&gt;.h</code> and <code>libtropic_&lt;cfp_name&gt;.h</code> are typically only needed when initializing the <code>lt_handle_t</code> instance \u2014 see the example below.</p>"},{"location":"reference/integrating_libtropic/how_to_use/#libtropic-bare-bone-example","title":"Libtropic Bare-Bone Example","text":"<p>The following bare-bone example shows how to initialize Libtropic, so it can be used to communicate with TROPIC01: <pre><code>#include \"libtropic_common.h\"\n#include \"libtropic.h\"\n#include \"libtropic_port_&lt;port_name&gt;.h\"\n#include \"libtropic_&lt;cfp_name&gt;.h\"\n\nint main(void) {\n    // 1. Declare a handle variable.\n    //\n    // The handle is a context for the whole communication between Libtropic\n    // and TROPIC01. Multiple handle instances can exist if it is needed to\n    // communicate with multiple TROPIC01 chips.\n    lt_handle_t h;\n\n    // 2. Declare a device structure.\n    //\n    // The device structure provides Libtropic with the device-specific\n    // information.\n    //\n    // IMPORTANT: This structure must exist throughout the whole life-cycle\n    // of the handle declared above, because the handle points to it,\n    // does not copy it!\n    lt_dev_&lt;port_name&gt;_t my_device;\n\n    // 3. Initialize the device structure.\n    //\n    // The members of the device structure are specific to the device - each\n    // device requires different members to be initialized.\n    my_device.first_member = \"some value for the first member\";\n    my_device.nth_member = \"some value for the n-th member\";\n\n    // 4. Save a pointer to the device structure inside the handle.\n    //\n    // Libtropic will then pass this structure to the HAL functions.\n    //\n    // IMPORTANT #1: The assignment below has to be done before calling\n    // lt_init() with the specific handle instance!\n    // IMPORTANT #2: One device structure cannot be shared among multiple\n    // handle instances!\n    h.l2.device = &amp;my_device;\n\n    // 5. Declare a context structure for the CFP (Cryptographic Functionality\n    // Provider).\n    //\n    // The context structure provides Libtropic with the memory location where\n    // it can save contexts of cryptographic functions. None of its members have\n    // to be initialized.\n    //\n    // IMPORTANT: This structure must exist throughout the whole life-cycle\n    // of the handle declared above, because the handle points to it,\n    // does not copy it!\n    lt_ctx_&lt;cfp_name&gt;_t my_crypto_ctx;\n\n    // 6. Save a pointer to the context structure inside the handle.\n    //\n    // Libtropic will then pass this structure to the CAL functions.\n    //\n    // IMPORTANT #1: The assignment below has to be done before calling\n    // lt_init() with the specific handle instance!\n    // IMPORTANT #2: One context structure cannot be shared among multiple\n    // handle instances!\n    h.l3.crypto_ctx = &amp;my_crypto_ctx;\n\n    // 7. Initialize the handle.\n    //\n    // This should be done only once for a specific handle.\n    // If you need to initialize the specific handle again, call lt_deinit()\n    // first.\n    lt_ret_t ret = lt_init(h);\n    if (LT_OK != ret) {\n        return -1;\n    }\n\n    // 8. Do your stuff.\n\n    // 9. Deinitialize the handle.\n    ret = lt_deinit(h);\n    if (LT_OK != ret) {\n        return -1;\n    }\n\n    return 0;\n}\n</code></pre></p> <p>How to apply this?</p> <p>If you don't know how to apply the information above, we recommend checking out our Tutorials, where we discuss some basic examples of using Libtropic in our standalone example projects in <code>examples/</code>.</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>To quickly get you started on your host platform, we prepared the following tutorials.</p> <p>First, we recommend starting with our TROPIC01 Model.</p>"},{"location":"tutorials/#a-i-want-to-play-with-the-tropic01-model","title":"A. I want to play with the TROPIC01 Model","text":"<p>Using TROPIC01 Model is a great way of evaluating the Libtropic SDK on your computer and discovering amazing TROPIC01 functionality without a need of a physical chip!</p> <p>Continue with the TROPIC01 Model Tutorials.</p>"},{"location":"tutorials/#b-i-want-the-real-deal","title":"B. I want the real deal","text":"<p>If you have already experimented with our TROPIC01 Model and you are ready to try the TROPIC01 chip, go ahead!</p> <p>Pick a set of tutorials based on your host platform:</p> <ul> <li> Linux<ul> <li> Linux SPI</li> <li> TROPIC01 USB Devkit</li> </ul> </li> <li> ESP32</li> <li> STM32</li> </ul>"},{"location":"tutorials/esp32/","title":"ESP32 Tutorials","text":"<p>These tutorials will help you get started with TROPIC01 on ESP32-based platforms using Libtropic. We will go through our examples in the <code>examples/esp32/</code> directory. In this directory, there are multiple subdirectories for each supported ESP32 board. Most of the instructions in this tutorial are common for all of the boards.</p>"},{"location":"tutorials/esp32/#hardware-setup","title":"Hardware Setup","text":""},{"location":"tutorials/esp32/#tropic01","title":"TROPIC01","text":"<p>TROPIC01 Devkit for ESP32 boards</p> <p>Currently, we don't offer a devkit for ESP32 boards. However, you can use any of our devkits that use SPI, except the USB DevKit.</p> <p>For the purpose of these tutorials, we will use our TROPIC01 Arduino Shield:</p>      TROPIC01 Arduino Shield pinout    <p>You can get TROPIC01 Arduino Shield and other devkits here.</p>"},{"location":"tutorials/esp32/#your-esp32-board","title":"Your ESP32 Board","text":"<p>Unfortunately, ESP32 boards and our Arduino shield are not plug-and-play, so please prepare some jump wires and use the figure above with Arduino Shield Pinout to help you during the setup. Follow the connection instructions for your ESP32 board below:</p> <p>Connection Instructions</p> ESP32-DevKitC-V4ESP32-S3-DevKitC-1ESP32-C3-DevKit-RUST-1 <p>ESP32-DevKitC-V4 pin layout here.  TROPIC01 Arduino Shield Pin ESP32-DevKitC-V4 Pin IOREF 3V3 +3V3 3V3 GND GND GPO GPIO32 MOSI GPIO23 MISO GPIO19 SCK GPIO18 CS GPIO5 <p>ESP32-S3-DevKitC-1 pin layout here.  TROPIC01 Arduino Shield Pin ESP32-S3-DevKitC-1 Pin IOREF 3V3 +3V3 3V3 GND GND GPO GPIO1 MOSI GPIO11 MISO GPIO13 SCK GPIO12 CS GPIO10 <p>ESP32-C3-DevKit-RUST-1 pin layout here.  TROPIC01 Arduino Shield Pin ESP32-C3-DevKit-RUST-1 Pin IOREF 3V3 +3V3 3V3 GND GND GPO GPIO10 MOSI GPIO1 MISO GPIO0 SCK GPIO3 CS GPIO8 <p>How to Use Different Pins?</p> <p>The pin connections above are used in our examples by default. The pins can be changed in each example's <code>main.c</code> \u2014 look for the <code>app_main()</code> function and adjust the initialization of the <code>lt_dev_esp_idf_t</code> structure.</p>"},{"location":"tutorials/esp32/#software-setup","title":"Software Setup","text":"<p>See below for instructions based on your OS:</p> <p>Installation Instructions</p>  Linux macOS Windows <ol> <li>Setup ESP-IDF and its dependencies:<ul> <li>Complete the first 4 steps in the official ESP-IDF setup guide.</li> <li>We recommend getting the 5.5.1 version, but any 5.x.x version should work.</li> </ul> </li> <li>Get the Libtropic repository:<ul> <li>Using git: <code>git clone https://github.com/tropicsquare/libtropic.git</code></li> <li>Or you can download the latest release.</li> </ul> </li> </ol> <p>TBA</p> <p>TBA</p>"},{"location":"tutorials/esp32/#start-with-our-tutorials","title":"Start with our Tutorials!","text":"<p>Do not skip!</p> <p>We strongly recommend going through each tutorial in this specific order without skipping. You will gather basic information about the chip and update your TROPIC01's firmware, which will guarantee compatibility with the latest Libtropic API.</p> <ol> <li>Chip Identification</li> <li>FW Update</li> <li>Hello, World!</li> </ol>"},{"location":"tutorials/esp32/#faq","title":"FAQ","text":"<p>If you encounter any issues, please check the FAQ before filing an issue or reaching out to our support.</p>"},{"location":"tutorials/esp32/fw_update/","title":"2. FW Update Example Tutorial","text":"<p>This example explains the firmware update process for both ABAB and ACAB silicon revisions. Use this example as a reference for integrating TROPIC01 firmware updates into your application. You will learn:</p> <ul> <li>How to read the current firmware versions.</li> <li>How to update the firmware using <code>lt_do_mutable_fw_update()</code>.</li> </ul> <p>TROPIC01 Firmware</p> <p>For more information about the firmware itself, refer to the TROPIC01 Firmware section.</p> <p>Firmware Update Precautions</p> <p>Use a stable power source and avoid disconnecting the TROPIC01 (devkit) or rebooting your host device (computer or microcontroller) during the update. Interrupting the firmware update can brick the device.</p>"},{"location":"tutorials/esp32/fw_update/#build-and-run","title":"Build and Run","text":"<p>Building and running the example</p>  Linux macOS Windows <p>Go to the example's project directory: <pre><code>cd examples/esp32/&lt;your_board&gt;/fw_update/\n</code></pre></p> <p>Build, flash and run the serial monitor using this command: <pre><code>idf.py build flash monitor\n</code></pre></p> <p>TBA</p> <p>TBA</p> <p>After this, you should see a colored output in your terminal.</p> <p>Next example </p>"},{"location":"tutorials/esp32/hello_world/","title":"3. Hello, World! Example Tutorial","text":"<p>This example demonstrates the basic Libtropic API and can be used to verify that the chip works correctly. In this example, you will learn about the following functions:</p> <ul> <li><code>lt_init()</code>: function used to initialize context for communication with the TROPIC01,</li> <li><code>lt_verify_chip_and_start_secure_session()</code>: helper function to start Secure Session and allow L3 communication,</li> <li><code>lt_ping()</code>: L3 command to verify communication with the TROPIC01,</li> <li><code>lt_session_abort()</code>: L3 command to abort Secure Session,</li> <li><code>lt_deinit()</code>: function used to deinitialize context.</li> </ul>"},{"location":"tutorials/esp32/hello_world/#build-and-run","title":"Build and Run","text":"<p>Building and running the example</p>  Linux macOS Windows <p>Go to the example's project directory: <pre><code>cd examples/esp32/&lt;your_board&gt;/hello_world/\n</code></pre></p> <p>Build, flash and run the serial monitor using this command: <pre><code>idf.py build flash monitor\n</code></pre></p> <p>TBA</p> <p>TBA</p> <p>After this, you should see a colored output in your terminal.</p> <p>If your TROPIC01 has engineering sample pairing keys, you can switch to them using the <code>LT_SH0_KEYS</code> CMake option:</p> <p>Switching to engineering sample pairing keys</p>  Linux macOS Windows <p>You can pass any CMake option to <code>idf.py</code> as follows: <pre><code>idf.py -DLT_SH0_KEYS=\"eng_sample\" build flash monitor\n</code></pre></p> <p>TBA</p> <p>TBA</p> <p>Additionally, see Default Pairing Keys for a Secure Channel Handshake for more information.</p>"},{"location":"tutorials/esp32/identify_chip/","title":"1. Chip Identification Example Tutorial","text":"<p>This example demonstrates how to read and display the chip\u2019s unique ID and firmware version information (bootloader, application and SPECT firmware versions). You will learn about the following functions:</p> <ul> <li><code>lt_reboot()</code>: L2 request to reboot to either Application or Maintenance Mode,</li> <li><code>lt_get_info_riscv_fw_ver()</code>, <code>lt_get_info_spect_fw_ver()</code>: L2 requests to read RISC-V CPU and SPECT firmware versions,</li> <li><code>lt_get_info_chip_id()</code>: L2 request to read chip identification (e.g., serial number).</li> </ul>"},{"location":"tutorials/esp32/identify_chip/#build-and-run","title":"Build and Run","text":"<p>Building and running the example</p>  Linux macOS Windows <p>Go to the example's project directory: <pre><code>cd examples/esp32/&lt;your_board&gt;/identify_chip/\n</code></pre></p> <p>Build, flash and run the serial monitor using this command: <pre><code>idf.py build flash monitor\n</code></pre></p> <p>TBA</p> <p>TBA</p> <p>After this, you should see a colored output in your terminal.</p> <p>Next example </p>"},{"location":"tutorials/linux/spi/","title":"Linux SPI Tutorials","text":"<p>These tutorials will help you get started with TROPIC01 on Linux-based systems with a hardware SPI interface. We will go through our examples in the <code>examples/linux/spi/</code> directory. The used port should be compatible with most Linux-based systems with a hardware SPI interface, including popular single-board computers such as the Raspberry Pi.</p>"},{"location":"tutorials/linux/spi/#hardware-setup","title":"Hardware Setup","text":"<p>For the purpose of these tutorials, we will use Raspberry Pi 4 as the host platform and our TROPIC01 Raspberry Pi Shield (available here). However, any other shield with TROPIC01's SPI pins exposed should work.</p>      TROPIC01 Raspberry Pi Shield    <p>Info</p> <p>If you're using our Raspberry Pi Shield, short the CS2 pins with a jumper.</p> <p>The aforementioned setup looks like the following:</p> Show images <p></p> <p></p> <p>I am not using TROPIC01 Raspberry Pi Shield, how to use different pins?</p> <p>The examples assume that TROPIC01 Raspberry Pi Shield is used by default. The pins and other things can be changed in each example's <code>main.c</code> \u2014 look for the <code>main()</code> function and adjust the initialization of the <code>lt_dev_linux_spi_t</code> structure.</p>"},{"location":"tutorials/linux/spi/#software-setup","title":"Software Setup","text":"<p>First, install the dependencies and prepare the repository:</p> <p>Installation Instructions</p> <ol> <li>Install CMake:<ul> <li>Ubuntu/Debian: <code>sudo apt update &amp;&amp; sudo apt install cmake</code></li> <li>Fedora: <code>sudo dnf install cmake</code></li> <li>Other: cmake.org</li> </ul> </li> <li>Install GCC and Make via your distribution's package manager:<ul> <li><code>sudo apt update &amp;&amp; sudo apt install build-essential</code></li> </ul> </li> <li>Get the Libtropic repository:<ul> <li>Using git: <code>git clone https://github.com/tropicsquare/libtropic.git</code></li> <li>Or you can download latest release.</li> </ul> </li> </ol> <p>After that, setup your system:</p> <p>System Setup Instructions</p> <p>Make sure that you have:</p> <ol> <li>The SPI kernel module enabled.<ul> <li>On Raspberry Pi, you can use raspi-config to enable the module.</li> </ul> </li> <li>Permissions to access the SPI and GPIO interface \u2014 on Raspberry Pi, you must be a member of the <code>spi</code> and <code>gpio</code> groups: <pre><code># Check if you are in the spi and the gpio group\ngroups\n# Add yourself to each group you are not in\nsudo usermod -aG spi \"$USER\"\nsudo usermod -aG gpio \"$USER\"\n# Log out and log in again to reflect changes.\n</code></pre></li> </ol>"},{"location":"tutorials/linux/spi/#start-with-our-tutorials","title":"Start with our Tutorials!","text":"<p>Do not skip!</p> <p>We strongly recommend going through each tutorial in this specific order without skipping. You will gather basic information about the chip and update your TROPIC01's firmware, which will guarantee compatibility with the latest Libtropic API.</p> <ol> <li>Chip Identification</li> <li>FW Update</li> <li>Hello, World!</li> </ol>"},{"location":"tutorials/linux/spi/#faq","title":"FAQ","text":"<p>If you encounter any issues, please check the FAQ before filing an issue or reaching out to our support.</p>"},{"location":"tutorials/linux/spi/fw_update/","title":"2. FW Update Example Tutorial","text":"<p>This example explains the firmware update process for both ABAB and ACAB silicon revisions. Use this example as a reference for integrating TROPIC01 firmware updates into your application. You will learn:</p> <ul> <li>How to read the current firmware versions.</li> <li>How to update the firmware using <code>lt_do_mutable_fw_update()</code>.</li> </ul> <p>TROPIC01 Firmware</p> <p>For more information about the firmware itself, refer to the TROPIC01 Firmware section.</p> <p>Firmware Update Precautions</p> <p>Use a stable power source and avoid disconnecting the TROPIC01 (devkit) or rebooting your host device (computer or microcontroller) during the update. Interrupting the firmware update can brick the device.</p>"},{"location":"tutorials/linux/spi/fw_update/#build-and-run","title":"Build and Run","text":"<p>Building and running the example</p>  Linux macOS Windows <p>Go to the example's project directory: <pre><code>cd examples/linux/spi/fw_update/\n</code></pre></p> <p>Create a <code>build/</code> directory and switch to it: <pre><code>mkdir build/\ncd build/\n</code></pre></p> <p>And finally, build and run the example: <pre><code>cmake ..\nmake\n./libtropic_fw_update\n</code></pre></p> <p>TBA</p> <p>TBA</p> <p>The example will prompt you for confirmation. Type <code>y</code> to start the update.</p> <p>After successful execution, your chip will contain the latest firmware and will be compatible with the current Libtropic API.</p> <p>Next example </p>"},{"location":"tutorials/linux/spi/hello_world/","title":"3. Hello, World! Example Tutorial","text":"<p>This example demonstrates the basic Libtropic API and can be used to verify that the chip works correctly. In this example, you will learn about the following functions:</p> <ul> <li><code>lt_init()</code>: function used to initialize context for communication with the TROPIC01,</li> <li><code>lt_verify_chip_and_start_secure_session()</code>: helper function to start Secure Session and allow L3 communication,</li> <li><code>lt_ping()</code>: L3 command to verify communication with the TROPIC01,</li> <li><code>lt_session_abort()</code>: L3 command to abort Secure Session,</li> <li><code>lt_deinit()</code>: function used to deinitialize context.</li> </ul>"},{"location":"tutorials/linux/spi/hello_world/#build-and-run","title":"Build and Run","text":"<p>Building and running the example</p>  Linux macOS Windows <p>Go to the example's project directory: <pre><code>cd examples/linux/spi/hello_world/\n</code></pre></p> <p>Create a <code>build/</code> directory and switch to it: <pre><code>mkdir build/\ncd build/\n</code></pre></p> <p>And finally, build and run the example: <pre><code>cmake ..\nmake\n./libtropic_hello_world\n</code></pre></p> <p>TBA</p> <p>TBA</p> <p>After this, you should see an output in your terminal.</p> <p>If your TROPIC01 has engineering sample pairing keys, you can switch to them using the <code>LT_SH0_KEYS</code> CMake option:</p> <p>Switching to engineering sample pairing keys</p>  Linux macOS Windows <p>You can pass <code>LT_SH0_KEYS</code> to <code>cmake</code> as follows: <pre><code>cmake -DLT_SH0_KEYS=\"eng_sample\" ..\nmake\n</code></pre></p> <p>TBA</p> <p>TBA</p> <p>Additionally, see Default Pairing Keys for a Secure Channel Handshake for more information.</p>"},{"location":"tutorials/linux/spi/identify_chip/","title":"1. Chip Identification Example Tutorial","text":"<p>This example demonstrates how to read and display the chip\u2019s unique ID and firmware version information (bootloader, application and SPECT firmware versions). You will learn about the following functions:</p> <ul> <li><code>lt_reboot()</code>: L2 request to reboot to either Application or Maintenance Mode,</li> <li><code>lt_get_info_riscv_fw_ver()</code>, <code>lt_get_info_spect_fw_ver()</code>: L2 requests to read RISC-V CPU and SPECT firmware versions,</li> <li><code>lt_get_info_chip_id()</code>: L2 request to read chip identification (e.g., serial number).</li> </ul>"},{"location":"tutorials/linux/spi/identify_chip/#build-and-run","title":"Build and Run","text":"<p>Building and running the example</p>  Linux macOS Windows <p>Go to the example's project directory: <pre><code>cd examples/linux/spi/identify_chip/\n</code></pre></p> <p>Create a <code>build/</code> directory and switch to it: <pre><code>mkdir build/\ncd build/\n</code></pre></p> <p>And finally, build and run the example: <pre><code>cmake ..\nmake\n./libtropic_identify_chip\n</code></pre></p> <p>TBA</p> <p>TBA</p> <p>After this, you should see an output in your terminal.</p> <p>Next example </p>"},{"location":"tutorials/linux/usb_devkit/","title":"TROPIC01 USB Devkit Tutorials","text":"<p>These tutorials will help you get started with our TROPIC01 USB Devkit (available here) mainly on Linux-based systems, but it should also be compatible with other POSIX systems. We will go through our examples in the <code>examples/linux/usb_devkit/</code> directory.</p>"},{"location":"tutorials/linux/usb_devkit/#hardware-setup","title":"Hardware Setup","text":"<p>As mentioned above, we will use our TROPIC01 USB Devkit (available here), specifically the TS1303 version, but other versions should also work:</p>      TROPIC01 USB Devkit (TS1303)    <p>Go ahead and plug the USB Devkit into your machine.</p>"},{"location":"tutorials/linux/usb_devkit/#software-setup","title":"Software Setup","text":"<p>First, install the dependencies and prepare the repository:</p> <p>Installation Instructions</p> <ol> <li>Install CMake:<ul> <li>Ubuntu/Debian: <code>sudo apt update &amp;&amp; sudo apt install cmake</code></li> <li>Fedora: <code>sudo dnf install cmake</code></li> <li>Other: cmake.org</li> </ul> </li> <li>Install GCC and Make via your distribution's package manager:<ul> <li><code>sudo apt update &amp;&amp; sudo apt install build-essential</code></li> </ul> </li> <li>Get the Libtropic repository:<ul> <li>Using git: <code>git clone https://github.com/tropicsquare/libtropic.git</code></li> <li>Or you can download the latest release.</li> </ul> </li> </ol> <p>After that, setup your system:</p> <p>System Setup Instructions</p> <p>Make sure you have access to a USB UART interface. Usually, your user account has to be a member of a certain group, usually the <code>dialout</code> group: <pre><code># Check if you are in the dialout group\ngroups\n# If not, add yourself to the dialout group\nsudo usermod -aG dialout \"$USER\"\n# Log out and log in again to reflect changes.\n</code></pre></p>"},{"location":"tutorials/linux/usb_devkit/#start-with-our-tutorials","title":"Start with our Tutorials!","text":"<p>Do not skip!</p> <p>We strongly recommend going through each tutorial in this specific order without skipping. You will gather basic information about the chip and update your TROPIC01's firmware, which will guarantee compatibility with the latest Libtropic API.</p> <ol> <li>Chip Identification</li> <li>FW Update</li> <li>Hello, World!</li> <li>Full Chain Verification</li> </ol>"},{"location":"tutorials/linux/usb_devkit/#faq","title":"FAQ","text":"<p>If you encounter any issues, please check the FAQ before filing an issue or reaching out to our support.</p>"},{"location":"tutorials/linux/usb_devkit/full_chain_verification/","title":"4. Full Chain Verification Example Tutorial","text":"<p>In this tutorial, you will learn about one of the steps required to verify the authenticity of the TROPIC01 certificate chain \u2014 a process that should be done by Tropic Square customers during provisioning of their device which integrates TROPIC01.</p> <p>Important: read before proceeding</p> <p>Detailed information about TROPIC01 device identity and related Tropic Square Public Key Infrastructure (PKI) is provided in the Device Identity and PKI Application Note (ODN_TR01_app_003) available on GitHub. It is recommended to read this document before proceeding to understand the process described in this tutorial, as here we provide only minimal information to try the process of the certificate chain verification.</p> <p>Compatibility</p> <p>Only production chips contain the full certificate chain. Sample chips are not supported by this tutorial. If you encounter problems in this tutorial, you probably have an incompatible chip. Find your TROPIC01's part number (check the FAQ) and check the Catalog list to see if your chip is a production one.</p> <p>The TROPIC01 comes with its own unique cryptographic identity in the form of a Secure Channel key pair and a certificate. The certificate is issued by Tropic Square PKI which provides a framework for verifying the origin of each TROPIC01 chip ever produced. In this tutorial, we will learn:</p> <ul> <li>How to load the certificate chain from a TROPIC01 chip using the <code>lt_get_info_cert_store()</code> function from the Libtropic API.</li> <li>How to verify all certificates in the chain using OpenSSL CLI with a provided script.</li> </ul>"},{"location":"tutorials/linux/usb_devkit/full_chain_verification/#load-the-certificates","title":"Load the Certificates","text":"<p>First, we will load the certificates from your TROPIC01 using a provided C application available in <code>examples/linux/usb_devkit/full_chain_verification</code>.</p> <p>Building and running the app</p>  Linux macOS Windows <p>Go to the example's project directory: <pre><code>cd examples/linux/usb_devkit/full_chain_verification/\n</code></pre></p> <p>Create a <code>build/</code> directory and switch to it: <pre><code>mkdir build/\ncd build/\n</code></pre></p> <p>And finally, build and run the application: <pre><code>cmake ..\nmake\n./libtropic_dump_certificates\n</code></pre></p> <p>The certificates will be stored in the build directory. If the application completed execution without any errors, you should see the following certificates in the build directory:</p> <ul> <li><code>t01_ca_cert.der</code></li> <li><code>t01_ese_cert.der</code></li> <li><code>t01_xxxx_ca_cert.der</code></li> <li><code>tropicsquare_root_ca_cert.der</code></li> </ul> <p>TBA</p> <p>TBA</p>"},{"location":"tutorials/linux/usb_devkit/full_chain_verification/#verify-the-certificates","title":"Verify the Certificates","text":"<p>After loading the certificates from the TROPIC01 chip, we will verify the certificates using a provided script.</p> <p>Verifying the certificates</p>  Linux macOS Windows <p>Go to the example's project directory: <pre><code>cd examples/linux/usb_devkit/full_chain_verification/\n</code></pre></p> <p>Run the <code>verify.sh</code> script. It accepts a single argument: a path to a directory where certificates that we loaded from the TROPIC01 are located. <pre><code>./verify.sh build/\n</code></pre></p> <p>If all certificates are verified successfully, the script will return 0 and output the following message: <code>All certificates verified successfully!</code></p> <p>TBA</p> <p>TBA</p>"},{"location":"tutorials/linux/usb_devkit/full_chain_verification/#understanding-the-script","title":"Understanding the Script","text":"<p>The script demonstrates almost all important steps in the verification process:</p> <ol> <li>Download revocation lists from the URLs specified in the certificates which we obtained from the TROPIC01.</li> <li>Check all certificates we obtained from the TROPIC01 using the chain and revocation lists we downloaded from the Tropic Square PKI website.</li> <li>Check the root certificate (simplified, no out-of-band check provided).</li> </ol> <p>Authenticity check of the root certificate in step 3 is not fully implemented. The root certificate can be obtained from the chip, we provide it in this repository and it is also available on the Tropic Square PKI website. Do not blindly trust this certificate file from GitHub alone. To protect against repository compromise, the trust has to be established by verifying the certificate fingerprint through an independent channel. Tropic Square customers can obtain the verified fingerprint via direct contact with Customer Support.</p> <p>The script contains comments about each step, so refer to the code of the script for more details about the implementation. It is also recommended to study the Device Identity and PKI Application Note (ODN_TR01_app_003) (available on GitHub) to fully understand the principles described in this tutorial.</p> <p>Alternative implementation of the verification</p> <p>The script verifies the TROPIC01 certificates against certificate authority certificates downloaded from the Tropic Square PKI website. As the same certificates are present also in the TROPIC01 itself, those can be used instead. The importance of verifying the root certificate independently remains the key part of the process.</p>"},{"location":"tutorials/linux/usb_devkit/fw_update/","title":"2. FW Update Example Tutorial","text":"<p>This example explains the firmware update process for both ABAB and ACAB silicon revisions. Use this example as a reference for integrating TROPIC01 firmware updates into your application. You will learn:</p> <ul> <li>How to read the current firmware versions.</li> <li>How to update the firmware using <code>lt_do_mutable_fw_update()</code>.</li> </ul> <p>TROPIC01 Firmware</p> <p>For more information about the firmware itself, refer to the TROPIC01 Firmware section.</p> <p>Firmware Update Precautions</p> <p>Use a stable power source and avoid disconnecting the TROPIC01 (devkit) or rebooting your host device (computer or microcontroller) during the update. Interrupting the firmware update can brick the device.</p>"},{"location":"tutorials/linux/usb_devkit/fw_update/#build-and-run","title":"Build and Run","text":"<p>Building and running the example</p>  Linux macOS Windows <p>Go to the example's project directory: <pre><code>cd examples/linux/usb_devkit/fw_update/\n</code></pre></p> <p>Create a <code>build/</code> directory and switch to it: <pre><code>mkdir build/\ncd build/\n</code></pre></p> <p>And finally, build and run the example: <pre><code>cmake ..\nmake\n./libtropic_fw_update\n</code></pre></p> <p>TBA</p> <p>TBA</p> <p>The example will prompt you for confirmation. Type <code>y</code> to start the update.</p> <p>After successful execution, your chip will contain the latest firmware and will be compatible with the current Libtropic API.</p> <p>Next example </p>"},{"location":"tutorials/linux/usb_devkit/hello_world/","title":"3. Hello, World! Example Tutorial","text":"<p>This example demonstrates the basic Libtropic API and can be used to verify that the chip works correctly. In this example, you will learn about the following functions:</p> <ul> <li><code>lt_init()</code>: function used to initialize context for communication with the TROPIC01,</li> <li><code>lt_verify_chip_and_start_secure_session()</code>: helper function to start Secure Session and allow L3 communication,</li> <li><code>lt_ping()</code>: L3 command to verify communication with the TROPIC01,</li> <li><code>lt_session_abort()</code>: L3 command to abort Secure Session,</li> <li><code>lt_deinit()</code>: function used to deinitialize context.</li> </ul>"},{"location":"tutorials/linux/usb_devkit/hello_world/#build-and-run","title":"Build and Run","text":"<p>Building and running the example</p>  Linux macOS Windows <p>Go to the example's project directory: <pre><code>cd examples/linux/usb_devkit/hello_world/\n</code></pre></p> <p>Create a <code>build/</code> directory and switch to it: <pre><code>mkdir build/\ncd build/\n</code></pre></p> <p>And finally, build and run the example: <pre><code>cmake ..\nmake\n./libtropic_hello_world\n</code></pre></p> <p>TBA</p> <p>TBA</p> <p>After this, you should see an output in your terminal.</p> <p>If your TROPIC01 has engineering sample pairing keys, you can switch to them using the <code>LT_SH0_KEYS</code> CMake option:</p> <p>Switching to engineering sample pairing keys</p>  Linux macOS Windows <p>You can pass <code>LT_SH0_KEYS</code> to <code>cmake</code> as follows: <pre><code>cmake -DLT_SH0_KEYS=\"eng_sample\" ..\nmake\n</code></pre></p> <p>TBA</p> <p>TBA</p> <p>Additionally, see Default Pairing Keys for a Secure Channel Handshake for more information.</p>"},{"location":"tutorials/linux/usb_devkit/identify_chip/","title":"1. Chip Identification Example Tutorial","text":"<p>This example demonstrates how to read and display the chip\u2019s unique ID and firmware version information (bootloader, application and SPECT firmware versions). You will learn about the following functions:</p> <ul> <li><code>lt_reboot()</code>: L2 request to reboot to either Application or Maintenance Mode,</li> <li><code>lt_get_info_riscv_fw_ver()</code>, <code>lt_get_info_spect_fw_ver()</code>: L2 requests to read RISC-V CPU and SPECT firmware versions,</li> <li><code>lt_get_info_chip_id()</code>: L2 request to read chip identification (e.g., serial number).</li> </ul>"},{"location":"tutorials/linux/usb_devkit/identify_chip/#build-and-run","title":"Build and Run","text":"<p>Building and running the example</p>  Linux macOS Windows <p>Go to the example's project directory: <pre><code>cd examples/linux/usb_devkit/identify_chip/\n</code></pre></p> <p>Create a <code>build/</code> directory and switch to it: <pre><code>mkdir build/\ncd build/\n</code></pre></p> <p>And finally, build and run the example: <pre><code>cmake ..\nmake\n./libtropic_identify_chip\n</code></pre></p> <p>TBA</p> <p>TBA</p> <p>After this, you should see an output in your terminal.</p> <p>Next example </p>"},{"location":"tutorials/model/","title":"TROPIC01 Model Tutorials","text":"<p>Using TROPIC01 Model is a great way of evaluating the Libtropic SDK on your computer and discovering amazing TROPIC01 functionality without a need of a physical chip!</p> <p>OS Support</p> <p>Currently we support Linux only. Support for macOS and Windows is being prepared.</p> <p>This tutorial assumes you are comfortable with using command line.</p> <p>First, we will prepare your environment by installing dependencies. Then, you can continue with our tutorials.</p>"},{"location":"tutorials/model/#install-dependencies-and-prepare-the-repository","title":"Install Dependencies and Prepare the Repository","text":"<p>See below for instructions based on your OS:</p> <p>Installation instructions</p>  Linux macOS Windows <ol> <li>Install Python<ul> <li>You can also use your distribution's package manager.<ul> <li>Fedora: <code>sudo dnf install python3</code></li> <li>Debian/Ubuntu: <code>sudo apt update &amp;&amp; sudo apt install python3</code></li> </ul> </li> </ul> </li> <li>Install CMake:<ul> <li>Ubuntu/Debian: <code>sudo apt update &amp;&amp; sudo apt install cmake</code></li> <li>Fedora: <code>sudo dnf install cmake</code></li> <li>Other: cmake.org</li> </ul> </li> <li>Install GCC and Make via your distribution's package manager<ul> <li>Some distributions offer complete development environment (including headers), so it's recommended to install this.</li> <li>Fedora: <code>sudo dnf group install development-tools</code></li> <li>Debian/Ubuntu: <code>sudo apt update &amp;&amp; sudo apt install build-essential</code></li> </ul> </li> <li>Get the Libtropic repository:<ul> <li>Using git: <code>git clone https://github.com/tropicsquare/libtropic.git</code></li> <li>Or you can download latest release.</li> </ul> </li> <li>Install TROPIC01 Model<ul> <li>Use our install script: <code>scripts/tropic01_model/install_linux.sh</code></li> <li>The script will create a virtual environment.</li> <li>Activate the environment: <code>source scripts/tropic01_model/.venv/bin/activate</code></li> </ul> </li> </ol> <p>TBA</p> <p>TBA</p>"},{"location":"tutorials/model/#start-experimenting-with-our-tutorials","title":"Start Experimenting with our Tutorials!","text":"<p>Paths</p> <p>All commands in all tutorials assume running from the repository root, unless they are preceded with <code>cd</code> (or similar) command. If you are running commands from elsewhere, make sure to correct paths in arguments.</p> <ol> <li>Your First Steps with Libtropic</li> <li>Understanding Libtropic</li> <li>Hardware Wallet</li> <li>Mac-And-Destroy</li> <li>Separate API</li> </ol>"},{"location":"tutorials/model/#details","title":"Details","text":"<p>This section provides more details about the TROPIC01 model for those interested.</p> <p>The model is provided by TROPIC Verification Library. See the repository for more details about the model and the source code. Below we discuss specifics of the TROPIC01 Model usage with Libtropic.</p>"},{"location":"tutorials/model/#how-it-works","title":"How it works?","text":"<p>The Libtropic uses the TCP HAL implemented in <code>hal/posix/tcp/libtropic_port_posix_tcp.c</code>, so both processes (the compiled binary and the model) communicate through a TCP socket at 127.0.0.1:28992. The SPI layer between Libtropic and the model is emulated through this TCP connection. The model responses match those of the physical TROPIC01 chip.</p>"},{"location":"tutorials/model/#model-configuration","title":"Model Configuration","text":"<p>Custom model configuration</p> <p>Custom configuration is for advanced users only and it is not supported by our examples and tests, as modifications are required.</p> <p>The TROPIC01 Model can be configured. To configure the model, pass a YAML configuration file to the model \u2014 see the Model Configuration section in the TROPIC Verification Library.</p> <p>For convenience, we provide a default model configuration (<code>scripts/tropic01_model/model_cfg.yml</code>), suitable for both examples and tests. If you want to customize the configuration, you can take this file as template and then modify the values according to the documentation. Internally, we generate the configuration from our provisioning data.</p> Advanced: Generating config from provisioning data <p>We provide both provisioning data and a Python script that can generate configuration for the model from such data. This is useful mainly for internal purposes, we describe it here for reference.</p> <p>To create a model configuration that will initialize the model to the state which is almost identical to a provisioned chip, use the <code>scripts/tropic01_model/create_model_cfg.py</code> script. Run <code>--help</code> to see available options and their explanation: <pre><code>cd scripts/tropic01_model/\npython3 create_model_cfg.py --help\n</code></pre></p> <p>The <code>--pkg-dir</code> Option</p> <p>The script expects a path to one of the lab batch packages inside <code>scripts/tropic01_model/provisioning_data/</code>. See Provisioning Data for more information.</p> <p>Using custom pairing keys</p> <p>If you change the pairing keys in the model's configuration, you will not be able to run our examples without modification, as they use default pairing keys. Each example contains <code>LT_EX_SH0_PRIV</code> and <code>LT_EX_SH0_PUB</code> at the beginning. Simply modify these constants to use arrays with your own keys to make examples work with custom keys.</p>"},{"location":"tutorials/model/first_steps/","title":"1. Your First Steps with Libtropic","text":"<p>Hello and welcome to Libtropic SDK! In the first tutorial, we will compile our first example.</p> <p>Before proceeding, make sure you have activated the virtual environment you installed the TROPIC01 Model in:</p> <p>Activating the virtual environment</p>  Linux macOS Windows <p>If the virtual environment is already activated, you will see \"(.venv)\" prefix in front of the prompt. For example:</p> <pre><code>(.venv) me@computer:~/libtropic$\n</code></pre> <p>If you don't see the \"(.venv)\" prefix, activate the environment:</p> <pre><code>source scripts/tropic01_model/.venv/bin/activate\n</code></pre> <p>TBA</p> <p>TBA</p> <p>Some examples require a fresh start of the model. You can start and terminate the model as following:</p> <p>Using the model</p>  Linux macOS Windows <p>Open a new console (or a new tab in your console emulator). Make sure you have the virtual environment activated. Type:</p> <pre><code>model_server tcp -c scripts/tropic01_model/model_cfg.yml\n</code></pre> <p>This will start a new TROPIC01 Model server. You can inspect the output after running examples if you are interested. Make sure you are running exactly one TROPIC01 Model server instance!</p> <p>To terminate the server, press Ctrl+C in the console.</p> <p>TBA</p> <p>TBA</p>"},{"location":"tutorials/model/first_steps/#hello-world-example","title":"Hello, World! Example","text":"<p>At first, let's see the Hello, World! example:</p> <p>Building and running the example</p>  Linux macOS Windows <p>Go to the example's project directory: <pre><code>cd examples/model/hello_world/\n</code></pre> Create a <code>build/</code> directory and switch to it: <pre><code>mkdir build/\ncd build/\n</code></pre> And finally, build and run the example <pre><code>cmake ..\nmake\n./libtropic_hello_world\n</code></pre></p> <p>TBA</p> <p>TBA</p> <p>You should see an output similar to this:</p> <pre><code>======================================\n==== TROPIC01 Hello World Example ====\n======================================\nPRNG initialized with seed=14758818\nInitializing handle...OK\nSending reboot request...OK\nStarting Secure Session with key slot 0...OK\nSending Ping command...\n        --&gt; Message sent to TROPIC01: 'This is Hello World message from TROPIC01!!'\n        &lt;-- Message received from TROPIC01: 'This is Hello World message from TROPIC01!!'\nAborting Secure Session...OK\nDeinitializing handle...OK\n</code></pre> <p>If you see the output, congratulations! \ud83c\udf89 You used Libtropic to send a Ping command with a message to the TROPIC01 Model!</p> <p>Next tutorial </p>"},{"location":"tutorials/model/hw_wallet/","title":"2. Hardware Wallet Example Tutorial","text":"<p>This example demonstrates how to use configuration objects and different pairing keys to manage access to TROPIC01 features. A hardware wallet device scenario is used as a model for this example.</p> <p>Prerequisites</p> <p>It is assumed that you have already completed the previous TROPIC01 Model tutorials. If not, start here.</p> <p>In this example, you will:</p> <ul> <li>Understand how the R-config is structured and how permissions are managed using the R-config.</li> <li> <p>Learn how the R-config can be modified using the Libtropic API:</p> <ul> <li><code>lt_r_config_erase()</code>: L3 command to erase the R-config.</li> <li><code>lt_write_whole_R_config()</code>: helper function to write the whole R-config with an instance of <code>struct lt_config_t</code>.</li> <li> <p><code>lt_read_whole_R_config()</code>: helper function to read the whole R-config into an instance of <code>struct lt_config_t</code>.</p> <p>Tip: Modifying Only One R-Config Register</p> <p>If you need to modify only one register in the R-config, you can use <code>lt_r_config_write()</code> or <code>lt_r_config_read()</code>.</p> </li> </ul> </li> <li> <p>Learn how to manage pairing keys:</p> <ul> <li><code>lt_pairing_key_write()</code>: L3 command to write a pairing key.</li> <li><code>lt_pairing_key_invalidate()</code>: L3 command to invalidate a pairing key.</li> </ul> </li> <li>Learn how to work with keys based on elliptic curves (ECC) on TROPIC01:<ul> <li><code>lt_ecc_key_store()</code>: L3 command to store an ECC key.</li> <li><code>lt_ecc_key_read()</code>: L3 command to read an ECC key.</li> <li><code>lt_ecc_key_generate()</code>: L3 command to generate an ECC key.</li> </ul> </li> <li>Learn how to use EDDSA to sign messages and verify signatures.</li> <li>Learn how to use a monotonic counter.</li> </ul>"},{"location":"tutorials/model/hw_wallet/#build-and-run","title":"Build and Run","text":"<p>Before proceeding, make sure you have activated the virtual environment you installed the TROPIC01 Model in and started it. If you're lost, see First Steps.</p> <p>Now, you can build and run the example:</p> <p>Building and running the example</p>  Linux macOS Windows <p>Go to the example's project directory: <pre><code>cd examples/model/hw_wallet/\n</code></pre> Create a <code>build/</code> directory and switch to it: <pre><code>mkdir build/\ncd build/\n</code></pre> And finally, build and run the example: <pre><code>cmake ..\nmake\n./libtropic_hw_wallet\n</code></pre></p> <p>TBA</p> <p>TBA</p> <p>Irreversible Changes</p> <p>Because this example writes and invalidates some Pairing Key slots (which are irreversible changes), the model has to be terminated and started again before running the example binary again. This action results in making the model behave like a fresh TROPIC01 chip again.</p> <p>Next tutorial </p>"},{"location":"tutorials/model/macandd/","title":"3. Mac-And-Destroy Example Tutorial","text":"<p>This example illustrates MAC-And-Destroy, the flagship feature of TROPIC01.</p> <p>Prerequisites</p> <p>It is assumed that you have already completed the previous TROPIC01 Model tutorials. If not, start here.</p> <p>You will learn about the following functions:</p> <ul> <li><code>lt_mac_and_destroy()</code>: L3 command to process MAC-and-Destroy operation,</li> <li><code>lt_r_mem_data_erase()</code>: L3 command to erase R-memory data slot,</li> <li><code>lt_r_mem_data_write()</code>: L3 command to write R-memory data slot,</li> <li><code>lt_r_mem_data_read()</code>: L3 command to read R-memory data slot,</li> <li><code>lt_random_value_get()</code>: function to generate random number using TROPIC01's TRNG.</li> </ul> <p>In this example, we also define two functions to implement PIN verification functionality:</p> <ul> <li><code>new_PIN_setup()</code>: setups the PIN,</li> <li><code>PIN_entry_check()</code>: checks the PIN.</li> </ul> <p>You can use these functions as an inspiration for your project.</p> <p>More Information</p> <p>For more information about Mac-And-Destroy, we recommend checking out the Pin Verification Application Note or the example's source code in <code>examples/model/mac_and_destroy/</code>.</p>"},{"location":"tutorials/model/macandd/#build-and-run","title":"Build and Run","text":"<p>Before proceeding, make sure you have activated the virtual environment you installed the TROPIC01 Model in and started it. If you're lost, see First Steps.</p> <p>Now, you can build and run the example:</p> <p>Building and running the example</p>  Linux macOS Windows <p>Go to the example's project directory: <pre><code>cd examples/model/mac_and_destroy/\n</code></pre> Create a <code>build/</code> directory and switch to it: <pre><code>mkdir build/\ncd build/\n</code></pre> And finally, build and run the example: <pre><code>cmake ..\nmake\n./libtropic_mac_and_destroy\n</code></pre></p> <p>TBA</p> <p>TBA</p> <p>Next tutorial </p>"},{"location":"tutorials/model/separate_api/","title":"4. Separate API Example Tutorial","text":"<p>This example showcases the Libtropic's Separate API. It is functionally similar to the Hello, World! example, but it uses distinct API calls for incoming and outgoing data. This approach is useful for secure, tunneled communication, such as during chip provisioning in a factory.</p> <p>Prerequisites</p> <p>It is assumed that you have already completed the previous TROPIC01 Model tutorials. If not, start here.</p> <p>You will learn about some of the low-level API functions used to process outgoing and incoming data. For example:</p> <ul> <li><code>lt_out__session_start()</code>: prepare Handshake_Req L2 request (for Secure Session establishment),</li> <li><code>lt_l2_send()</code>: send L2 request,</li> <li><code>lt_l2_receive()</code>: receive L2 response,</li> <li><code>lt_in__session_start()</code>: process L2 response to the Handshake_Req.</li> </ul>"},{"location":"tutorials/model/separate_api/#build-and-run","title":"Build and Run","text":"<p>Before proceeding, make sure you have activated the virtual environment you installed the TROPIC01 Model in and started it. If you're lost, see First Steps.</p> <p>Now, you can build and run the example:</p> <p>Building and running the example</p>  Linux macOS Windows <p>Go to the example's project directory: <pre><code>cd examples/model/separate_api/\n</code></pre> Create a <code>build/</code> directory and switch to it: <pre><code>mkdir build/\ncd build/\n</code></pre> And finally, build and run the example: <pre><code>cmake ..\nmake\n./libtropic_separate_api\n</code></pre></p> <p>TBA</p> <p>TBA</p>"},{"location":"tutorials/model/understanding_libtropic/","title":"2. Understanding Libtropic","text":""},{"location":"tutorials/stm32/","title":"STM32 Tutorials","text":"<p>These tutorials will help you get started with TROPIC01 on STM32-based platforms using Libtropic. Currently, we officially support Nucleo F439ZI and Nucleo L432KC development boards.</p> <p>We will go through our examples in the <code>examples/stm32/</code> directory. In this directory, there are multiple subdirectories for each supported Nucleo board. Most of the instructions in this tutorial are common for all of the boards.</p>"},{"location":"tutorials/stm32/#hardware-setup","title":"Hardware Setup","text":"<p>Connection Instructions</p> Nucleo F439ZINucleo L432KC <p>The Nucleo F439ZI board is compatible with our TROPIC01 Arduino Shield, which we recommend for this tutorial. You can get the shield here.</p> <p>      TROPIC01 Arduino Shield pinout  </p> <p>If you have any other shield which exposes SPI connections (or a custom PCB), you can use it as well, but you have to connect it manually e.g., using DuPont (jumper) wires. Refer to the table below for wiring:</p> TROPIC01 NUCLEO F439ZI GND GND 3V3 3V3 MISO (SDO) GPIOA_6 MOSI (SDI) GPIOA_7 SCK GPIOA_5 CS (CSN) GPIOD_14 GPO GPIOF_15 <p>We do not offer a shield compatible with the Nucleo L432KC. You can use any of our shields (available here) which expose SPI connections (or a custom PCB). Connect the TROPIC01 to the Nucleo L432KC according to the table below:</p> TROPIC01 NUCLEO L432KC GND GND 3V3 3V3 MISO (SDO) A6 MOSI (SDI) A5 SCK A4 CS (CSN) A3 Advanced: How to Use Different Nucleo Pins? <p>The pin assignments above are used in our examples by default. The pins can be changed in the source code of each example. However, apart from changing assignment, you also have to initialize different peripherals, which is not documented here.</p>"},{"location":"tutorials/stm32/#software-setup","title":"Software Setup","text":"<p>First, install the dependencies and prepare the repository:</p> <p>Installation Instructions</p>  Linux macOS Windows <ol> <li>Install CMake:<ul> <li>Ubuntu/Debian: <code>sudo apt update &amp;&amp; sudo apt install cmake</code></li> <li>Fedora: <code>sudo dnf install cmake</code></li> <li>Other: cmake.org</li> </ul> </li> <li>Install Make:<ul> <li>Ubuntu/Debian: <code>sudo apt update &amp;&amp; sudo apt install make</code></li> <li>Fedora: <code>sudo dnf install make</code></li> </ul> </li> <li>Install GCC cross-compiler for ARM:<ul> <li>Ubuntu/Debian: <code>sudo apt update &amp;&amp; sudo apt install gcc-arm-none-eabi</code></li> <li>Fedora: <code>sudo dnf install arm-none-eabi-gcc</code></li> </ul> </li> <li>Install OpenOCD:<ul> <li>Ubuntu/Debian: <code>sudo apt update &amp;&amp; sudo apt install openocd</code></li> <li>Fedora: <code>sudo dnf install openocd</code></li> </ul> </li> <li>Install a serial monitor of your choice (<code>minicom</code>, <code>screen</code>, <code>GTKTerm</code>).<ul> <li>For beginners we recommend GUI-based GTKTerm.<ul> <li>Ubuntu/Debian: <code>sudo apt update &amp;&amp; sudo apt install gtkterm</code></li> <li>Fedora: <code>sudo dnf install gtkterm</code></li> </ul> </li> </ul> </li> <li>Get the Libtropic repository:<ul> <li>Using git: <code>git clone https://github.com/tropicsquare/libtropic.git</code></li> <li>Or you can download the latest release.</li> </ul> </li> </ol> <p>TBA</p> <p>TBA</p> <p>After that, setup your system:</p> <p>System Setup Instructions</p>  Linux macOS Windows <p>To upload the example programs, you need to have access to USB devices (usually, you must be a member of the <code>plugdev</code> group). Also, permissions (udev rules) have to be correctly configured, refer to the OpenOCD documentation.</p> <p>As the output of examples is printed to the serial port, you need an access to it. Either run the serial port monitor as root, or you have to add yourself to a group with access to serial ports. Usually, you must be a member of the <code>dialout</code> group.</p> <pre><code># Check if you are in the plugdev and the dialout groups. Required groups can\n# be different, check the documentation of your Linux distribution\ngroups\n# Add yourself to each group you are not in\nsudo usermod -aG plugdev \"$USER\"\nsudo usermod -aG dialout \"$USER\"\n# Log out and log in again to reflect changes\n</code></pre> <p>TBA</p> <p>TBA</p>"},{"location":"tutorials/stm32/#start-with-our-tutorials","title":"Start with our Tutorials!","text":"<p>Do not skip!</p> <p>We strongly recommend going through each tutorial in this specific order without skipping. You will gather basic information about the chip and update your TROPIC01's firmware, which will guarantee compatibility with the latest Libtropic API.</p> <ol> <li>Chip Identification</li> <li>FW Update</li> <li>Hello, World!</li> </ol>"},{"location":"tutorials/stm32/#faq","title":"FAQ","text":"<p>If you encounter any issues, please check the FAQ before filing an issue or reaching out to our support.</p>"},{"location":"tutorials/stm32/fw_update/","title":"2. FW Update Example Tutorial","text":"<p>This example explains the firmware update process for both ABAB and ACAB silicon revisions. Use this example as a reference for integrating TROPIC01 firmware updates into your application. You will learn:</p> <ul> <li>How to read the current firmware versions.</li> <li>How to update the firmware using <code>lt_do_mutable_fw_update()</code>.</li> </ul> <p>TROPIC01 Firmware</p> <p>For more information about the firmware itself, refer to the TROPIC01 Firmware section.</p> <p>Firmware Update Precautions</p> <p>Use a stable power source and avoid disconnecting the TROPIC01 (devkit) or rebooting your host device (computer or microcontroller) during the update. Interrupting the firmware update can brick the device.</p>"},{"location":"tutorials/stm32/fw_update/#build-and-run","title":"Build and Run","text":"<p>Building and running the example</p>  Linux macOS Windows <p>Go to the example's project directory: <pre><code>cd examples/stm32/&lt;your_board&gt;/fw_update/\n</code></pre></p> <p>Create a <code>build/</code> directory and switch to it: <pre><code>mkdir build/\ncd build/\n</code></pre></p> <p>Open your STM32's serial port using your preferred serial monitor with configuration 8-N-1 and baudrate set to 115200. By default, the serial port is mapped to <code>/dev/ttyACM0</code>. For example, using GTKTerm: <pre><code>gtkterm -p /dev/ttyACM0 -s 115200\n</code></pre></p> <p>Warning</p> <p>Make sure only one serial monitor has the STM32's serial port open, otherwise your output may appear mangled.</p> <p>And finally, build and run the example: <pre><code>cmake ..\nmake\nmake flash\n</code></pre></p> <p>TBA</p> <p>TBA</p> <p>After this, you should see a colored output in your serial monitor.</p> <p>Next example </p>"},{"location":"tutorials/stm32/hello_world/","title":"3. Hello, World! Example Tutorial","text":"<p>This example demonstrates the basic Libtropic API and can be used to verify that the chip works correctly. In this example, you will learn about the following functions:</p> <ul> <li><code>lt_init()</code>: function used to initialize context for communication with the TROPIC01,</li> <li><code>lt_verify_chip_and_start_secure_session()</code>: helper function to start Secure Session and allow L3 communication,</li> <li><code>lt_ping()</code>: L3 command to verify communication with the TROPIC01,</li> <li><code>lt_session_abort()</code>: L3 command to abort Secure Session,</li> <li><code>lt_deinit()</code>: function used to deinitialize context.</li> </ul>"},{"location":"tutorials/stm32/hello_world/#build-and-run","title":"Build and Run","text":"<p>Building and running the example</p>  Linux macOS Windows <p>Go to the example's project directory: <pre><code>cd examples/stm32/&lt;your_board&gt;/hello_world/\n</code></pre></p> <p>Create a <code>build/</code> directory and switch to it: <pre><code>mkdir build/\ncd build/\n</code></pre></p> <p>Open your STM32's serial port using your preferred serial monitor with configuration 8-N-1 and baudrate set to 115200. By default, the serial port is mapped to <code>/dev/ttyACM0</code>. For example, using GTKTerm: <pre><code>gtkterm -p /dev/ttyACM0 -s 115200\n</code></pre></p> <p>Warning</p> <p>Make sure only one serial monitor has the STM32's serial port open, otherwise your output may appear mangled.</p> <p>And finally, build and run the example: <pre><code>cmake ..\nmake\nmake flash\n</code></pre></p> <p>TBA</p> <p>TBA</p> <p>After this, you should see an output in your serial monitor.</p> <p>If your TROPIC01 has engineering sample pairing keys, you can switch to them using the <code>LT_SH0_KEYS</code> CMake option:</p> <p>Switching to engineering sample pairing keys</p>  Linux macOS Windows <p>You can pass <code>LT_SH0_KEYS</code> to <code>cmake</code> as follows: <pre><code>cmake -DLT_SH0_KEYS=\"eng_sample\" ..\nmake\n</code></pre></p> <p>TBA</p> <p>TBA</p> <p>Additionally, see Default Pairing Keys for a Secure Channel Handshake for more information.</p>"},{"location":"tutorials/stm32/identify_chip/","title":"1. Chip Identification Example Tutorial","text":"<p>This example demonstrates how to read and display the chip\u2019s unique ID and firmware version information (bootloader, application and SPECT firmware versions). You will learn about the following functions:</p> <ul> <li><code>lt_reboot()</code>: L2 request to reboot to either Application or Maintenance Mode,</li> <li><code>lt_get_info_riscv_fw_ver()</code>, <code>lt_get_info_spect_fw_ver()</code>: L2 requests to read RISC-V CPU and SPECT firmware versions,</li> <li><code>lt_get_info_chip_id()</code>: L2 request to read chip identification (e.g., serial number).</li> </ul>"},{"location":"tutorials/stm32/identify_chip/#build-and-run","title":"Build and Run","text":"<p>Building and running the example</p>  Linux macOS Windows <p>Go to the example's project directory: <pre><code>cd examples/stm32/&lt;your_board&gt;/identify_chip/\n</code></pre></p> <p>Create a <code>build/</code> directory and switch to it: <pre><code>mkdir build/\ncd build/\n</code></pre></p> <p>Open your STM32's serial port using your preferred serial monitor with configuration 8-N-1 and baudrate set to 115200. By default, the serial port is mapped to <code>/dev/ttyACM0</code>. For example, using GTKTerm: <pre><code>gtkterm -p /dev/ttyACM0 -s 115200\n</code></pre></p> <p>Warning</p> <p>Make sure only one serial monitor has the STM32's serial port open, otherwise your output may appear mangled.</p> <p>And finally, build and run the example: <pre><code>cmake ..\nmake\nmake flash\n</code></pre></p> <p>TBA</p> <p>TBA</p> <p>After this, you should see a colored output in your serial monitor.</p> <p>Next example </p>"}]}